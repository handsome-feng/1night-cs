## 数据结构

### 树

#### 二叉树用在什么情况

二叉树，本质上，是对链表和数组的一个折中
在链表中，插入、删除速度很快，但查找速度较慢。
在数组中，查找速度很快，但插入删除速度很慢。
为了解决这个问题，找寻一种能够在插入、删除、查找、遍历等操作都相对快的容器，于是人们发明了二叉树。

#### 哈希表与红黑树

咋一看，hashtable的优势是很明显的：

1. 查找、插入、删除速度都为O(1), 而红黑树的查找、插入、删除速度为O(logn). 但红黑树有很重要的特征是hashtable所不具备的：
2. 有序的特征,红黑树遍历可以得出有序输出，但hashtable是无序输出。
3. 如果需要求某一范围的输出，红黑树可以完美解决
4. hashtable的最恶劣的情况是效率很低的(比如需要resize时），而红黑树不存在这种情况。

#### 二叉搜索树

### 红黑树

set/map底层都是用红黑树实现的

## 算法

### 如何判断一个点在多边形内

### 多个字符串中如何找到前缀相同最长的两个字符串

### 堆，哈系，红黑树，哈夫曼树，二叉排序树

### 棋子走日字，从左下角到右上角，有多少走法

### 一分钟公交通过概率为p，3min呢

### mysql数据存储过程，B数，哈析表

### 如何查看单链表倒数第K个数据

设链表的长度为 N。设两个指针 P1 和 P2指向单链表头部，先让 P1 移动 K 个节点，则还有 N - K 个节点可以移动。此时让 P1 和 P2 同时移动，可以知道当 P1 移动到链表结尾时，P2 移动到 N - K 个节点处，该位置就是倒数第 K 个节点。

### 找到链表中环的入口节点

1. 找环中相汇点。分别用p1，p2指向链表头部，p1每次走一步，p2每次走二步，直到**p1==p2**找到在环中的相汇点。
2. 找环的长度。从环中的相汇点开始, p2不动, p1前移，当再次相遇时，p1刚好绕环一周,其移动即为**环的长度K**
3. 求换的起点, 转换为求环的倒数第N-K个节点，则两指针left和right均指向起始,right先走K步,然后两个指针开始同步移动,当两个指针再次相遇时,right刚好绕环一周回到起点,left则刚好走到了起点位置

### 二维数组中的查找

在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
**思路:**
从右上角开始查找。因为矩阵中的一个数，它左边的数都比它小，下边的数都比它大。因此，从右上角开始查找，就可以根据 target 和当前元素的大小关系来缩小查找区间。

复杂度：O(M+N) + O(1)

### 从尾到头打印链表

1. 使用栈
2. 使用递归(本质也是栈)
3. 使用头插法

### 斐波那契数列

动态规划

### 在O(1)时间内删除链表节点

1. 如果该节点不是尾节点，那么可以直接**将下一个节点的值赋给该节点**，令该节点指向下下个节点，然后删除下一个节点，时间复杂度为 O(1)。
2. 否则，就需要先遍历链表，找到节点的前一个节点，然后让前一个节点指向 null，时间复杂度为 O(N)。

### 设计包含min函数的栈

除了题目要求的栈之外**新开一个栈**,用来记录最小值,每当在原栈中push数据后,与最小值栈中的栈顶元素比较,如果新值较小,则在最小值栈中push新值;否则**再次push栈顶元素**.
pop的时候,只要将最小值栈也pop一下就行了.
这样,min函数只需要返回最小值栈的栈顶元素即可.

```c
public void push(int node) {
    stack.push(node);
    if (min > node) min = node;
    minStack.push(min);
}
```

**一个优化:**
一般说来,最小值不会每次都需要更新,因此最小值栈里面会有很多重复元素.因此一个简单的优化就是只在新值<=原最小值时才pushIntoMin,注意这个==的条件是不可少的,这是为了防止在pop的时候错误的pop最小值.pop的时候,只有pop值==最小值时才popMinStack, 其他时候不对最小值栈进行pop

### 从上到下打印二叉树

层序遍历直接想到的应该是基于队列实现。从上到下打印二叉树的规律：每一次打印一个结点的时候，如果该结点有子结点，则把该结点的子结点放到一个队列的末尾。接下来到队列头部取出最早进入队列的结点，重复前面的打印操作，直到队列中所有的结点都被打印出来为止。

## 排序算法

### 选择排序

```c++
template<typename T>
void selectionSort (T arr[], int n) {
    for (int i = 0; i < n; i++) {
        int minIndex = i;
        for (int j = i + 1; j < n; j++)
            if (arr[j] < arr[minIndex])
                minIndex = j;

        swap (arr[i], arr[minIndex]);
    }
}
```

### 插入排序

```c++
template<typename T>
void insertionSort (T arr[], int n) {
    for (int i = 1; i < n; i++) {
        // 寻找arr[i]合适的插入位置
        for (int j = i; j > 0 && arr[j] < arr[j-1]; j--) {
            swap (arr[j], arr[j-1]);  //一次交换=三次赋值
        }
    }
}
```

```c++
template<typename T>
void insertionSort2 (T arr[], int n) {
    for (int i = 1; i < n; i++) {
        T e = arr[i];
        int j; //保存元素e应该插入的位置
        for (j = i; j > 0 && arr[j-1] > e; j--) {
            arr[j] = arr[j-1]; //向后移动
        }
        arr[j] = e;
    }
}
```

对于近乎有序的数组，效率极高，近似于O(n)。

### 冒泡排序

### 合并排序

### 快速排序

