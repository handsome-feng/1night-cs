# 计算机组成与设计

## 计算机的语言：MIPS

| 寄存器    | 寄存器号 | 用途                       | 调用时是否保存 |
| --------- | -------- | -------------------------- | -------------- |
| $zero     | 0        | 常数0                      | 不适用         |
| $v0 - $v1 | 2 ~ 3    | 返回值                     | 否             |
| $a0 - $a3 | 4 ~ 7    | 参数                       | 否             |
| $t0 - $t7 | 8 ~ 15   | 临时变量                   | 否             |
| $s0 - $s7 | 16 ~ 23  | 对应保存的变量             | 是             |
| $t8 - $t9 | 24 ~ 25  | 更多临时变量               | 否             |
| $gp       | 28       | 指向静态数据区的保留寄存器 | 是             |
| $sp       | 29       | 栈指针                     | 是             |
| $fp       | 30       | 帧指针                     | 是             |
| $ra       | 31       | 返回地址                   | 是             |
| $at       | 1        | 汇编器保留                 |                |
| $k0 - $k1 | 26 ~ 27  | 操作系统保留               |                |



32个的理由：

1. 越小越快
2. 指令格式位数的限制



指令：

add    $s1, $s2, $s3    # $s1 = $s2 + $s3

sub    $s1, $s2, $s3    # $s1 = $s2 - $s3

addi   $s1, $s2, 20      # $s1 = $s2 + 20



补码取反加1原理：
$$
x + \bar{x} = -1 \\
x + \bar{x} + 1 = 0 \\
-x = \bar{x} + 1
$$

将有符号数作为无符号数来处理，是一种检验 0 <= x < y 的低开销方法，常用于检查数组的下标是否越界



```c
int fact (int n)
{
    if (n < 1) return (1);
    else return (n * fact(n - 1));
}
```

```assembly
fact:
	addi $sp, $sp, -8
	sw   $ra, 4($sp)
	sw   $a0, 0($sp)
	slti $t0, $a0, 1     # test for n < 1
	beq  $t0, $zero, L1
	addi $v0, $zero, 1   # return 1
	addi $sp, $sp, 8     # pop 2 items, 本应该加载$a0和$ra，但是n<1时，没有变化
	jr   $ra
L1: addi $a0, $a0, -1
    jal   fact           # call fact with (n - 1)
    lw   $a0, 0($sp)     # return from jal: restore argument n
    lw   $ra, 4($sp)
    addi $sp, $sp, 8
    mul  $v0, $a0, $v0   # return n * fact (n - 1)
    jr   $ra
```

