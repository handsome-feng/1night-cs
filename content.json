{"pages":[{"title":"About","date":"2020-05-22T12:03:32.788Z","path":"about/index.html","text":""},{"title":"Categories","date":"2020-05-22T12:03:32.788Z","path":"categories/index.html","text":""},{"title":"Tags","date":"2020-05-22T12:03:32.788Z","path":"tags/index.html","text":""}],"posts":[{"title":"vim","date":"2020-05-22T12:03:32.788Z","path":"wiki/tools/vim/","text":"Su-writeIf you find you do not have permission to perform :w, use the following: 1:w !sudo tee &quot;%&quot; &gt; /dev/null You can make a command so :W invokes sudo: 1command W w !sudo tee &quot;%&quot; &gt; /dev/null Or, if you know about the problem beforehand: 12sudoedit path_to_filesudo -e path_to_file 查找向下查找 /searchstring 向上查找 ?searchstring n N 重复上次查找 set incsearch 设置增量查找 set noincsearch 关闭增量查找 匹配以The开始的行 /^The 匹配以.结束的行 /.$ 匹配任意linu开始的任意词 /linu. 匹配以abc结束的字 \\abc&gt; 匹配以abc开始的字 &lt;abc 匹配以abc开始的任意字 \\abc* 匹配除abc开头外的任意字 [^abc] 匹配任意字母和数字 /[a-aA-Z0-9] 显示当前文档及编辑信息 CTRL+G 分屏 打开文件并且分屏 vim -o[n] file1 [file2 ...] vim -O[n] file1 [file2 ...] 小写o是水平分屏,大写O是垂直分屏;中括号表示可有可无,n分屏的个数 在vim中的命令模式下分屏 a. 垂直分屏 1:vs [file2] 垂直分屏,后面不跟文件名是将当前文件垂直分屏;跟文件名是将新文件在垂直分屏中打开(也可用 vsp或者vsplit代替vs) 快捷键操作可以不学: 垂直分屏的快捷键操作为:ctrl+w v(同时按下ctrl和w键后,松开再按v键:快捷键操作只可将当前文件分屏) b.水平分屏 :sv [file2] 水平分屏,后面不跟文件名是将当前文件水平分屏;跟文件名是将新文件在水平分屏中打开(也可用 sp或者split代替sv) 快捷键操作可以不学: 水平的快捷键操作为:ctrl+w s(同时按下ctrl和w键后,松开再按s键:快捷键操作只可将当前文件分屏) c. 新建文件水平分屏 :new [newfile] 此命令会新建一个水平分屏 如果跟有文件名则会新建一个文件,当写入内容并且保存退出后会新建该文件(如果没有写入内容保存退出也不会新建该文件); 快捷键操作可以不学: 新建文件水平分屏的快捷键操作为:ctrl+w n(同时按下ctrl和w键后,松开再按n键) 如果没有跟文件名,在写入内容后保存时命令模式下输入: :w filename 会新建一个名字为filename的文件 移动光标 a. 把光标移到右边的屏中 ctrl+w l b. 把光标移到左边的屏中 ctrl+w h c. 把光标移到上边的屏中 ctrl+w k d. 把光标移到下边的屏中 ctrl+w j e. 把光标移到下一个屏中 ctrl+w w f. 把光标移到上一个屏中 ctrl+w p 移动分屏 a. 向右移动 ctrl+w L b. 向左移动 ctrl+w H c. 向上移动 ctrl+w K d. 向下移动 ctrl+w J e. 向下旋转窗口 ctrl+w r f. 向上旋转窗口 ctrl+w R g. 当前窗口与下一个窗口对调 ctrl+w x 控制分屏的尺寸 a. 减少当前窗口高度（对上下分屏才有用） ctrl+w - 亲测字体大小会发生变化 b. 增加当前窗口高度（对上下分屏才有用） ctrl+w + 亲测字体大小会发生变化 c. 增加当前窗口宽度（对左右分屏才有用） ctrl+w &gt; 按完ctrl w 后松开,同时按下shift &gt; d. 减少当前窗口宽度（对左右分屏才有用） ctrl+w &lt; 按完ctrl w 后松开,同时按下shift &lt; e. 使所有窗口恢复均等 ctrl+w = 关闭分屏 a. 关闭除当前分屏外的其他分屏 :only 快捷键操作 快捷操作为:ctrl+w o(最后一个分屏不能用此快捷键关闭) b. 关闭当前分屏 &gt;快捷操作为:ctrl+w c (最后一个分屏不能用此快捷键关闭) c. 关闭当前分屏 &gt;快捷操作为:ctrl+w q (可用来关闭最后一个分屏) d. 关闭所有分屏 :qa","tags":[],"categories":[{"name":"tools","slug":"tools","permalink":"https://handsome-feng.github.io/1night-cs/categories/tools/"}]},{"title":"","date":"2020-05-22T12:03:32.788Z","path":"wiki/tools/x2x/","text":"x2x does exactly what you want: 1$ ssh -X othermachine x2x -west -to :0 Now you can move your mouse to the left of your laptop and it wii appear in that other machine. Keyboard ‘goes’ there too. You’ll need to enable X forwarding in that other machine’s sshd.","tags":[],"categories":[{"name":"tools","slug":"tools","permalink":"https://handsome-feng.github.io/1night-cs/categories/tools/"}]},{"title":"","date":"2020-05-22T12:03:32.788Z","path":"wiki/tools/xdotool/","text":"xdotool getmouselocation My extra for sequential clicking into a few positions is a file positions.txt (given by a few eval/echo runs): 123123 13423 243232 989 And the code that uses it is: 123456while read line; do X=`echo $line| cut -c1-3`; Y=`echo $line| cut -c4-7`; xdotool mousemove --sync $(( 0.5 + $X )) $(( 0.5 + $Y )); xdotool click 1done &lt; positions.txt If there is no need to scale pixels (unlike my case), it could be a simple 1234while read line; do xdotool mousemove --sync $line; xdotool click 1done &lt; positions.txt","tags":[],"categories":[{"name":"tools","slug":"tools","permalink":"https://handsome-feng.github.io/1night-cs/categories/tools/"}]},{"title":"","date":"2020-05-22T12:03:32.788Z","path":"wiki/tools/xrdp/","text":"Server: 12345sudo apt install xrdpsudo adduser xrdp ssl-certsudo systemctl restart xrdpsudo ufw allow 3389 log: /var/log/xrdp.logconfigure: /etc/xrdp/xrdp.inistartup: /etc/xrdp/startwm which invode /etc/X11/Xsession","tags":[],"categories":[{"name":"tools","slug":"tools","permalink":"https://handsome-feng.github.io/1night-cs/categories/tools/"}]},{"title":"","date":"2020-05-22T12:03:32.788Z","path":"wiki/tools/xwd/","text":"12xwd -out screenshot.xwd -root -display :0.0convert /tmp/screenshot.xwd /tmp/screenshot.png","tags":[],"categories":[{"name":"tools","slug":"tools","permalink":"https://handsome-feng.github.io/1night-cs/categories/tools/"}]},{"title":"","date":"2020-05-22T12:03:32.784Z","path":"wiki/tools/lsof/","text":"","tags":[],"categories":[{"name":"tools","slug":"tools","permalink":"https://handsome-feng.github.io/1night-cs/categories/tools/"}]},{"title":"autoconf","date":"2020-05-22T12:03:32.784Z","path":"wiki/tools/autoconf/","text":"The configuration scripts produced by Autoconf are independent of Autoconf when they are run, so their users do not need to have Autoconf. Autoconf requirements_x000D_ AC_INIT(package, version, bug-report-address)x000D information on the package_x000D_ checks for programs_x000D_ checks for libraries_x000D_ checks for header files_x000D_ checks for types_x000D_ checks for structures_x000D_ checks for compiler characteristics_x000D_ checks for library functions_x000D_ checks for system services_x000D_ AC_CONFIG_FILES([file…])x000D AC_OUTPUT if you want the package to use a configuration header file, you must add a call to AC_CONFIG_HEADERS When using autoscan to maintain a configure.ac, simply consider adding its suggestions. The file autoscan.log contains detailed information on why a macro is requested. Using ifnames to List Conditionals. If you give autoconf an argument, it reads that file instead of configure.ac and writes the configuration script to the standard output instead of to configure. If you give autoconf the argument -, it reads from the standard input instead of configure.ac and writes the configuration script to the standard output. Some of the files are distributed with Autoconf; autoconf reads them first. Then it looks for the optional file acsite.m4 in the directory that contains the distributed Autoconf macro files, and for the optional file aclocal.m4 in the current directory.","tags":[],"categories":[{"name":"tools","slug":"tools","permalink":"https://handsome-feng.github.io/1night-cs/categories/tools/"}]},{"title":"","date":"2020-05-22T12:03:32.784Z","path":"wiki/tools/geekbench/","text":"wget http://cdn.geekbench.com/Geekbench-5.5.0-Linux.tar.gztar -xzvf Geekbench-5.5.0-Linux.tar.gzcd Geekbench-5.5.0-Linux./geekbench5","tags":[],"categories":[{"name":"tools","slug":"tools","permalink":"https://handsome-feng.github.io/1night-cs/categories/tools/"}]},{"title":"Git","date":"2020-05-22T12:03:32.784Z","path":"wiki/tools/git/","text":"常用命令1234567891011121314151617181920# 新建并且切换到branch-namegit checkout -b &lt;branch-name&gt;# 合并branch-name的filename到当前分支git checkout branch-name filenamegit remote -vgit remote add origin-gitlab git@salsa.debian.org:handsome_feng-guest/ukui-session-manager.gitgit push origin-gitlab debian:mastergit cherry-pick &lt;commit-id&gt;git cherry-pick &lt;start-commit-id&gt;..&lt;end-commit-id&gt;git submodule update --initgit revert &lt;commit-id&gt;git reset# 比较两个分支的某个目录git diff master focal-dev debian 将本地debian分支推送到远程origin-debian的master分支： git push origin-debain debian:master 删除本地分支： git branch -d &lt;branchName&gt; 删除远程分支： git push origin --delete &lt;branchName&gt; 切换分支： git checkout -b debian remotes/origin/debian 合并某个分支的特定文件：git checkout [branch] [file name] 合并两个分支git remote add new-origin git@github.com:handsome-feng/new.git git merge new-origin/master --allow-unreleated-histories 删除某个commitgit rebase -i previous_commit bzr to git123456cp -pr repo-dir repo-dir_backup # Make a backupcd repo-dir # Change into your dirgit init # Initialise a new git repobzr fast-export --plain . | git fast-import # Do the actual conversiongit co -f master # Will reply &apos;Already on master&apos;rm -rf .bzr/ # Remove the bzr data Removing files from Git history$ java -jar bfg.jar --delete-folders .git --delete-files .git --no-blob-protection my-repo.git git使用代理1234567# 设置代理git config --global http.proxy socks5://127.0.0.1:1080git config --global https.proxy socks5://127.0.0.1:1080# 取消代理git config --global --unset http.proxygit config --global --unset https.proxy 将项目一部分分离出来，作为独立项目12345git subtree split -P dir_name -b branch_namemkdir ../branch_namecd ../branch_namegit initgit pull ../old_project branch_name","tags":[],"categories":[{"name":"tools","slug":"tools","permalink":"https://handsome-feng.github.io/1night-cs/categories/tools/"}]},{"title":"GPG","date":"2020-05-22T12:03:32.784Z","path":"wiki/tools/gpg/","text":"https://wiki.debian.org/Keysigning Create key123456$ cat &gt;&gt; ~/.gnupg/gpg.conf &lt;&lt;EOF&gt; personal-digest-preferences SHA256&gt; cert-digest-algo SHA256&gt; default-preference-list SHA512 SHA384 SHA256 SHA224 AES256 AES192 AES CAST5 ZLIB BZIP2 ZIP Uncompressed&gt; EOF$ gpg --full-generate-key private key: decrypt emails sent to you digitally sign emails public key: send you encrypted mail verify emails you send. revocation certificate: What happens if you lose access to a secret key, or it stops being secret? A revocation certificate is a file that you can generate that announces that you no longer trust that key. You generate it when you still have the secret key, and keep it for any future disaster. replacing keyshttps://keyring.debian.org/ Ubuntuhttps://help.ubuntu.com/community/GnuPrivacyGuardHowto","tags":[],"categories":[{"name":"tools","slug":"tools","permalink":"https://handsome-feng.github.io/1night-cs/categories/tools/"}]},{"title":"Hexchat","date":"2020-05-22T12:03:32.784Z","path":"wiki/tools/hexchat/","text":"Q: How to avoid ‘’No ping reply for %d seconds” A: /set net_ping_timeout 0","tags":[],"categories":[{"name":"tools","slug":"tools","permalink":"https://handsome-feng.github.io/1night-cs/categories/tools/"}]},{"title":"","date":"2020-05-22T12:03:32.784Z","path":"wiki/tools/irc/","text":"https://vijaikumar.in/keeping-your-irccloud-client-always-connected-for-free-82db71b3cff3","tags":[],"categories":[{"name":"tools","slug":"tools","permalink":"https://handsome-feng.github.io/1night-cs/categories/tools/"}]},{"title":"","date":"2020-05-22T12:03:32.784Z","path":"wiki/tools/regex/","text":"vim如何用正则表达式把数字换成相同长度的空格 :%s/\\d/ /g","tags":[],"categories":[{"name":"tools","slug":"tools","permalink":"https://handsome-feng.github.io/1night-cs/categories/tools/"}]},{"title":"scrcpy","date":"2020-05-22T12:03:32.784Z","path":"wiki/tools/scrcpy/","text":"Home page Shortcuts Action Shortcut Shortcut (macOS) Switch fullscreen mode Ctrl+f Cmd+f Resize window to 1:1 (pixel-perfect) Ctrl+g Cmd+g Resize window to remove black borders Ctrl+x | Double-click¹ Cmd+x | Double-click¹ Click on HOME Ctrl+h | Middle-click Ctrl+h | Middle-click Click on BACK Ctrl+b | Right-click² Cmd+b | Right-click² Click on APP_SWITCH Ctrl+s Cmd+s Click on MENU Ctrl+m Ctrl+m Click on VOLUME_UP Ctrl+↑ (up) Cmd+↑ (up) Click on VOLUME_DOWN Ctrl+↓ (down) Cmd+↓ (down) Click on POWER Ctrl+p Cmd+p Power on Right-click² Right-click² Turn device screen off (keep mirroring) Ctrl+o Cmd+o Expand notification panel Ctrl+n Cmd+n Collapse notification panel Ctrl+Shift+n Cmd+Shift+n Copy device clipboard to computer Ctrl+c Cmd+c Paste computer clipboard to device Ctrl+v Cmd+v Copy computer clipboard to device Ctrl+Shift+v Cmd+Shift+v Enable/disable FPS counter (on stdout) Ctrl+i Cmd+i ¹Double-click on black borders to remove them.²Right-click turns the screen on if it was off, presses BACK otherwise. QA: Mouse/keyboard didn’t work.","tags":[],"categories":[{"name":"tools","slug":"tools","permalink":"https://handsome-feng.github.io/1night-cs/categories/tools/"}]},{"title":"","date":"2020-05-22T12:03:32.784Z","path":"wiki/tools/screen/","text":"screen命令可以实现当前窗口与任务分离，我们即使离线了，服务器仍在后台运行任务。当我们重新登录服务器，可以读取窗口线程，重新连接任务窗口。 创建新窗口 123screenscreen -S namescreen command 分离 ctrl a+d screen -d name 恢复 screen -ls screen -r 杀死 ctrl a+k ctrl a ，输入quit 清理窗口 screen -wipe","tags":[],"categories":[{"name":"tools","slug":"tools","permalink":"https://handsome-feng.github.io/1night-cs/categories/tools/"}]},{"title":"","date":"2020-05-22T12:03:32.784Z","path":"wiki/tools/ssh/","text":"1.限制用户登录： /etc/ssh/sshd_config： AllowUsers user1 user2@192.168.1.1 DenyUsers user3 user4 限制 IP登录 通过设置 /etc/hosts.allow 和 /etc/hosts.deny 这个两个文件 /etc/hosts.allow： sshd:192.168.1.1:allowsshd:192.168.1.1/24:allow /etc/hosts.allow： sshd:ALL # 允许全部的 ssh 登录 hosts.allow &gt; hosts.deny (优先级)","tags":[],"categories":[{"name":"tools","slug":"tools","permalink":"https://handsome-feng.github.io/1night-cs/categories/tools/"}]},{"title":"优麒麟20.04远程桌面","date":"2020-05-22T12:03:32.784Z","path":"wiki/tools/ubuntu-2004-vnc-server/","text":"server: 1234567891011121314151617$ sudo apt install tightvncserver xfce4 openssh-server$ vncserver #set password$ vncserver -kill :1$ cat ~/.vnc/xstartup#!/bin/bashxrdb %HOME/.Xresourcesunset SESSION_MANAGERunset DBUS_SESSION_BUS_ADDRESSstartxfce4 &amp;$ vncserver #restart the VNC server// open port 5901 if you have UFW firewall enabled$ sudo ufw allow from any to any port 5901 proto tcp client: 123$ sudo apt instsall xtightvncviewer$ sh -L 5901:127.0.0.1:5901 -N -f -l server_user_name vnc_server_ip$ vncviewer vnc_server_ip:1 vnc server system startup script 123456789101112131415$ cat /etc/systemd/system/vncserver@.server[Unit]Description=Systemd VNC server startup script for Ubuntu 20.04After=syslog.target network.target[Service]Type=forkingUser=fengExecStartPre=-/usr/bin/vncserver -kill :%i &amp;&gt; /dev/nullExecStart=/usr/bin/vncserver -depth 24 -geometry 800x600 :%iPIDFile=/home/feng/.vnc/%H:%i.pidExecStop=/usr/bin/vncserver -kill :%i[Install]WantedBy=multi-user.target","tags":[],"categories":[{"name":"tools","slug":"tools","permalink":"https://handsome-feng.github.io/1night-cs/categories/tools/"}]},{"title":"","date":"2020-05-22T12:03:32.784Z","path":"wiki/tools/v2ray/","text":"服务器端: 注册域名 注册cloudflare Add your site 添加域名解析记录，选择A记录，name填www，IPv4填写你的搬瓦工VPS的IP，云朵请点成灰色仅dns解析，先不使用CDN 提示修改Nameservers，并提供了两个域名服务器地址，在你的域名注册商那修改域名服务器即可 SSL设置为Full 安装v2ray bash &lt;(curl -s -L https://git.io/v2ray.sh) 传输协议选择4:WebSocket+TLS 确认域名已经解析到vps地址，然后输入正确的域名 v2ray url生成vmess url链接，用户配置客户端 客户端： 12wget https://install.direct/go.shsudo bash go.sh 将配置文件拷贝到/etc/v2ray/config.json 1sudo systemctl start v2ray chromium –proxy-server=”socks5://127.0.0.1:1080” 终端代理： export（测试无效） 12export http_proxy=127.0.0.1:1080export https_proxy=127.0.0.1:1080 Use proxychains: sudo proxychains apt update vim /etc/proxychains.conf 12[ProxyList]socks5 127.0.0.1 1080","tags":[],"categories":[{"name":"tools","slug":"tools","permalink":"https://handsome-feng.github.io/1night-cs/categories/tools/"}]},{"title":"","date":"2020-05-22T12:03:32.768Z","path":"wiki/index/","text":"在线工具在线贴图工具在线贴文字工具在线gif制作在线流程图 实用工具 Youcompleteme gollum irssi goldendict Beyond Compare SS xdotool 服务器 discuz wordpress 启动流程 BIOS Kernel lightdm session-manager 设备 终端: /dev/tty1 … /dev/pts/0 … 常用命令 包管理 系统监控 网络 ifconfig netstat tcpdump wireshark 跨版本 Flatpak Snap Appimage 其他 ANSI控制码","tags":[],"categories":[]},{"title":"","date":"2020-05-22T12:03:32.768Z","path":"wiki/debian&ubuntu/Theme/","text":"","tags":[],"categories":[{"name":"debian&ubuntu","slug":"debian-ubuntu","permalink":"https://handsome-feng.github.io/1night-cs/categories/debian-ubuntu/"}]},{"title":"","date":"2020-05-22T12:03:32.768Z","path":"wiki/debian&ubuntu/UpstreamGuide/","text":"","tags":[],"categories":[{"name":"debian&ubuntu","slug":"debian-ubuntu","permalink":"https://handsome-feng.github.io/1night-cs/categories/debian-ubuntu/"}]},{"title":"","date":"2020-05-22T12:03:32.768Z","path":"wiki/debian&ubuntu/watch/","text":"","tags":[],"categories":[{"name":"debian&ubuntu","slug":"debian-ubuntu","permalink":"https://handsome-feng.github.io/1night-cs/categories/debian-ubuntu/"}]},{"title":"","date":"2020-05-22T12:03:32.768Z","path":"wiki/device/网卡/","text":"","tags":[],"categories":[{"name":"device","slug":"device","permalink":"https://handsome-feng.github.io/1night-cs/categories/device/"}]},{"title":"","date":"2020-05-22T12:03:32.768Z","path":"wiki/language/qt/","text":"","tags":[],"categories":[{"name":"language","slug":"language","permalink":"https://handsome-feng.github.io/1night-cs/categories/language/"}]},{"title":"Debian Maintainer","date":"2020-05-22T12:03:32.768Z","path":"wiki/debian&ubuntu/DebianMaintainer/","text":"Becoming a Debian MaintainerIdentification generate a strong (&gt;=2048) RSA GnuPG key. Send the fingerprint to DD to sign it. Import the key received from DD: $ gpg --import handsome_feng(B43C0E3B\\)–Public.asc Confirm the key signed success: $ gpg --recv-key DD_public_key_ID `$ gpg –list-sigs Update the key by send it to the key server. $ gpg --keyserver pool.sks-keyservers.net --send-key 2811C825B43C0E3B Declaration of intent Subscribe to the debian-devel-announce mailing list Ensure that GnuPG uses SHA2 signatures (in preference to SHA1); an example is having the following content in ~/.gnupg/gpg.conf: 123personal-digest-preferences SHA512cert-digest-algo SHA512default-preference-list SHA512 SHA384 SHA256 SHA224 AES256 AES192 AES CAST5 ZLIB BZIP2 ZIP Uncompressed Register for a Salsa account Register for a New Members account. emailing sso@rt.debian.org (Don’t forget to sign your emil) 12345678910To: sso@rt.debian.orgSubject: [Debian RT] SSO Account for _____Please create a SSO Account for me.Account name: _____-guestReason account is needed: _____OpenPGP key fingerprint: _____Thanks. After receive the debsso account, use the Alioth icon on the right hand side at https://sso.debian.org to login. Open https://sso.debian.org/alioth/certs/enroll_csr/ to get certificate. 12345678910$ openssl genrsa -out handsome_feng-guest@users.alioth.debian.org.key 2048$ openssl req -new -sha256 -key handsome_feng-guest@users.alioth.debian.org.key -batch# Paste the CSR and click the 'Get certificate' button to get the handsome_feng-guest@users.alioth.debian.org.crt# Authenticate access via curl$ curl --key handsome_feng-guest@users.alioth.debian.org.key --cert handsome_feng-guest@users.alioth.debian.org.crt https://sso.debian.org/ca/test/env# Combine key and certificate in a pkcs12 file that can be imported in browsers (Type the password for the export, PS: such as your login password)$ openssl pkcs12 -export -out handsome_feng-guest@users.alioth.debian.org.p12 -inkey handsome_feng-guest@users.alioth.debian.org.key -in handsome_feng-guest@users.alioth.debian.org.crt Import the xx.p12 from the certificate dialog at chrome://settings/certificates or from the command line with: 1pk12util -i handsome_feng-guest@users.alioth.debian.org.p12 -d sql:$HOME/.pki/nssdb Then you can login the https://nm.debian.org/ referencehttps://wiki.debian.org/DebianSingleSignOn https://wiki.debian.org/Keysigning https://wiki.debian.org/DebianMaintainer","tags":[],"categories":[{"name":"debian&ubuntu","slug":"debian-ubuntu","permalink":"https://handsome-feng.github.io/1night-cs/categories/debian-ubuntu/"}]},{"title":"","date":"2020-05-22T12:03:32.768Z","path":"wiki/debian&ubuntu/Debuild/","text":"debuild – clean","tags":[],"categories":[{"name":"debian&ubuntu","slug":"debian-ubuntu","permalink":"https://handsome-feng.github.io/1night-cs/categories/debian-ubuntu/"}]},{"title":"","date":"2020-05-22T12:03:32.768Z","path":"wiki/debian&ubuntu/NonMaintainerUpload/","text":"https://wiki.debian.org/NonMaintainerUpload","tags":[],"categories":[{"name":"debian&ubuntu","slug":"debian-ubuntu","permalink":"https://handsome-feng.github.io/1night-cs/categories/debian-ubuntu/"}]},{"title":"SRU","date":"2020-05-22T12:03:32.768Z","path":"wiki/debian&ubuntu/SRU/","text":"SRU:https://wiki.ubuntu.com/StableReleaseUpdateshttp://people.canonical.com/~ubuntu-archive/pending-sru.html debdiff:Using ~/.quiltrc configuration file1234567QUILT_PATCHES=debian/patchesQUILT_NO_DIFF_INDEX=1QUILT_NO_DIFF_TIMESTAMPS=1QUILT_REFRESH_ARGS=\"-p ab\"QUILT_DIFF_ARGS=\"--color=auto\" # If you want some color when using `quilt diff`.QUILT_PATCH_OPTS=\"--reject-format=unified\"QUILT_COLORS=\"diff_hdr=1;32:diff_add=1;34:diff_rem=1;31:diff_hunk=1;33:diff_ctx=35:diff_cctx=33\" If source format is ‘quilt’12$ apt-get source kylin-nm$ pull-lp-source &lt;package_name&gt; trusty Import a patch 12$ quilt import -P fix-foobar.patch /tmp/patch$ quilt push Or create a new patch 123456$ quilt new fix-foobar.patch# use the editor from quilt$ quilt edit foobar.c# or use your favorable editor# $ quilt add file-to-modify &amp;&amp; $ vim file-to-modify$ quilt refresh 123$ update-maintainer$ debuild -S$ debdiff kylin-nm_1.0.0-1.dsc kylin-nm_1.0.0-1ubuntu0.1.dsc &gt; kylin-nm_1.0.0-1ubuntu0.1.debdiff if source format is ‘native’1234$ pull-lp-source kylin-nm trusty# then edit it$ debuild -sa -S$ defdiff kylin-nm_1.0.0-1.dsc kylin-nm_1.0.0-1ubuntu0.1.dsc &gt; kylin-nm_1.0.0-1ubuntu0.1.debdiff reference: https://wiki.ubuntu.com/UbuntuStudio/DebDiff https://wiki.debian.org/UsingQuilt","tags":[],"categories":[{"name":"debian&ubuntu","slug":"debian-ubuntu","permalink":"https://handsome-feng.github.io/1night-cs/categories/debian-ubuntu/"}]},{"title":"","date":"2020-05-22T12:03:32.768Z","path":"wiki/debian&ubuntu/SimplePackaging/","text":"https://wiki.debian.org/SimplePackagingTutorial Download the upstream source as tarball.Rename it to _.orig.tar.gz (eg. node-pretty-hrtime_1.0.3.orig.tar.gz). Untar the tarball.Rename the directory to - (eg. node-pretty-hrtime-1.0.3). Switch to the above directory (eg. cd node-pretty-hrtime-1.0.3) and run debmake. Make package lintian clean.Run lintian command and make sure to fix all the errors and warnings (lines starting with E: or W:) shown. Changelog file can be edited using the following command dch -e Update debian/copyright with any missing information. 1cme update dpkg-copyright Run debclean or clean before running git commit to ensure files generated by dpkg-buildpackage are not committed. File ITP (Intend To Package). Clean build with sbuild/pbuild. Make sure that the package builds in a clean minimal chroot. AptCacherNg can be set up to save bandwidth and make builds faster. Push the repo to salsa.debian.org. Request sponsorship.","tags":[],"categories":[{"name":"debian&ubuntu","slug":"debian-ubuntu","permalink":"https://handsome-feng.github.io/1night-cs/categories/debian-ubuntu/"}]},{"title":"","date":"2020-05-22T12:03:32.768Z","path":"wiki/debian&ubuntu/UK-NO1/","text":"慢既是快 全局快捷键 统一的帮助文档","tags":[],"categories":[{"name":"debian&ubuntu","slug":"debian-ubuntu","permalink":"https://handsome-feng.github.io/1night-cs/categories/debian-ubuntu/"}]},{"title":"","date":"2020-05-22T12:03:32.768Z","path":"wiki/debian&ubuntu/UbuntuMember/","text":"参考： https://wiki.ubuntu.com/AndreasHasenack/UbuntuServerDevApplication 2018.1.29: https://wiki.ubuntu.com/fossfreedom/budgie-extrasPPUApplication https://wiki.ubuntu.com/fossfreedom/UbuntuBudgieDevApplication https://wiki.ubuntu.com/slashd/coredev 2018.2.26 1https://wiki.ubuntu.com/tsimonq2/Applications/Qt5Uploader 2018.4.10 1https://wiki.ubuntu.com/handsome_feng/UbuntuKylinDeveloperApplication 1https://wiki.ubuntu.com/DeveloperMembershipBoard/Agenda https://irclogs.ubuntu.com/2018/02/26/%23ubuntu-meeting.html My workubuntukylin-default-settings: 1670202 https://qa.debian.org/developer.php?login=jianfengli%40ubuntukylin.com https://launchpad.net/~feng-kylin/+uploaded-packages https://irclogs.ubuntu.com/2018/04/09/%23ubuntu-meeting.html Can I see some diffs of what you actually uploaded to Ubuntu with sponsorship? I’m not sure how to get that： https://launchpad.net/ubuntu/+source/qtbase-opensource-src/5.9.3+dfsg-0ubuntu1 19:34https://launchpad.net/ubuntu/+source/qtsvg-opensource-src/5.9.3-0ubuntu1 Please link directly to the upload. Example: https://launchpad.net/ubuntu/+source/ukui-session-manager/1.1.1-0ubuntu1 12345678[~]$ who-uploads -M 10 budgie-desktopUploads for budgie-desktop:10.2.8-1 to unstable: Gianfranco Costamagna &lt;locutusofborg@debian.org&gt;10.2.7-3 to unstable: Adam Borowski &lt;kilobyte@angband.pl&gt;10.2.7-2 to unstable: Gianfranco Costamagna &lt;locutusofborg@debian.org&gt;10.2.7-1 to unstable: Gianfranco Costamagna &lt;locutusofborg@debian.org&gt;10.2.6-2 to unstable: Gianfranco Costamagna &lt;locutusofborg@debian.org&gt;10.2.6-1 to unstable: Gianfranco Costamagna &lt;locutusofborg@debian.org&gt; 1http://ubuntu-dev.alioth.debian.org/cgi-bin/ubuntu-sponsorships.cgi?render=htm&amp;sponsoree=*foss* ukui-session-manager： 自带配置文件","tags":[],"categories":[{"name":"debian&ubuntu","slug":"debian-ubuntu","permalink":"https://handsome-feng.github.io/1night-cs/categories/debian-ubuntu/"}]},{"title":"","date":"2020-05-22T12:03:32.768Z","path":"wiki/debian&ubuntu/comman-procedure/","text":"Debiannew package:ITP Package removal:给ftp.debian.org 提bug： https://wiki.debian.org/ftpmaster_Removals UbuntuFFe SRU Package removal：https://wiki.ubuntu.com/UbuntuDevelopment/PackageArchive","tags":[],"categories":[{"name":"debian&ubuntu","slug":"debian-ubuntu","permalink":"https://handsome-feng.github.io/1night-cs/categories/debian-ubuntu/"}]},{"title":"common command","date":"2020-05-22T12:03:32.768Z","path":"wiki/debian&ubuntu/command/","text":"查找find使用格式如下： $ find &lt;指定目录&gt; &lt;指定条件&gt; &lt;指定动作&gt; - &lt;指定目录&gt;： 所要搜索的目录及其所有子目录。默认为当前目录。 - &lt;指定条件&gt;： 所要搜索的文件的特征。 - &lt;指定动作&gt;： 对搜索结果进行特定的处理。 使用实例： $ find . -name ‘test*’ 搜索当前目录（含子目录，以下同）中，所有文件名以test开头的文件。 $ find . -name ‘test*’ -ls 搜索当前目录中，所有文件名以test开头的文件，并显示它们的详细信息。 $ find . -type f -mmin -10 搜索当前目录中，所有过去10分钟中更新过的普通文件。如果不加-type f参数，则搜索普通文件+特殊文件+目录。 locate它不搜索具体目录，而是搜索一个数据库（/var/lib/locatedb），这个数据库中含有本地所有文件信息。Linux系统自动创建这个数据库，并且每天自动更新一次，所以使用locate命令查不到最新变动过的文件。为了避免这种情况，可以在使用locate之前，先使用updatedb命令，手动更新数据库。 locate命令的使用实例： $ locate /etc/sh 搜索etc目录下所有以sh开头的文件。 $ locate ~/m 搜索用户主目录下，所有以m开头的文件。 $ locate -i ~/m 搜索用户主目录下，所有以m开头的文件，并且忽略大小写。 whereiswhereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。 whereis命令的使用实例： $ whereis grep whichwhich命令的作用是，在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。 which命令的使用实例： $ which grep typetype命令其实不能算查找命令，它是用来区分某个命令到底是由shell自带的，还是由shell外部的独立二进制文件提供的。如果一个命令是外部命令，那么使用-p参数，会显示该命令的路径，相当于which命令。 type命令的使用实例： $ type cd 系统会提示，cd是shell的自带命令（build-in）。 $ type grep 系统会提示，grep是一个外部命令，并显示该命令的路径。 $ type -p grep 加上-p参数后，就相当于which命令。 包管理dpkgdpkg -x dpkg -e dpkg-deb -b 设备信息sudo /sbin/hdparm -i /dev/sda | grep -i serialno #硬盘序列号 X相关xwininfoxpropxkillxdotool用户管理： adduser feng usermod -aG sudo feng","tags":[],"categories":[{"name":"debian&ubuntu","slug":"debian-ubuntu","permalink":"https://handsome-feng.github.io/1night-cs/categories/debian-ubuntu/"}]},{"title":"手动定制优麒麟镜像","date":"2020-05-22T12:03:32.768Z","path":"wiki/debian&ubuntu/custom-iso/","text":"手动集成版本流程如下： 点击基础iso镜像，右键挂载镜像: sudo mount xxx.iso /mnt/uk64 创建一个image-iso目录，拷贝挂载镜像的所有文件到image-iso目录（注意隐藏文件不要漏掉了） cd /image-iso rsync -a /mnt/uk64 . 将image-iso/casper/filesystem.squashfs 移动到工作目录下: sudo mv uk64/casper/filesystem.squashfs . 解压缩文件，生成squashfs-root目录 sudo unsquashfs filesystem.squashfs chroot进入squashfs-root目录，命令： sudo chroot squashfs-root 进入chroot后第一个操作为mount： 1234mount -t proc proc /procmount -t sysfs sysfs /sysmount -t devtmpfs devtmpfs /devmount -t devpts devpts /dev/pts 配置chroot环境中的网络、apt源等（配置网络修改/etc/resolv.conf，修改源更改/etc/apt/sources.list文件,添加multiverse) vim.tiny /etc/resolv.conf: nameserver 114.114.114.114 chroot环境中安装包、删除包、修改配置文件等 123add-apt-repository ppa:feng-kylin/1810aidapt-get install foxitreader flashplugin-installer libgconf-2-4apt purge apport apport-gtk apport-symptoms python-apport gnome-software gnome-software-common ubuntu-software libreoffice-* mate-polkit kylin-greeter windows字体 添加可执行权限和可读权限sudo cp -r huawen_font /usr/share/fontschmod +rx -R huawen_font 更新字体缓存，执行命令 fc-cache -v -f 更新开机动画 (可选，主题包postinst文件里有) 1234567update-alternatives \\ --install /usr/share/plymouth/themes/default.plymouth default.plymouth \\ /usr/share/plymouth/themes/ubuntukylin-logo/ubuntukylin-logo.plymouth 150update-alternatives \\ --install /usr/share/plymouth/themes/text.plymouth text.plymouth \\ /usr/share/plymouth/themes/ubuntukylin-text/ubuntukylin-text.plymouth 150update-initramfs -u 更新grub主题 (可选) 123if [ -e /boot/grub/grub.cfg ]; then update-grub || truefi 还原定制版本中修改的配置文件及清除缓存，如/etc/resolv.conf文件，/var/cache/apt/archives目录下的deb包，/var/lib/apt/lists目录下的apt更新list文件等 12345678add-apt-repository -r ppa:feng-kylin/1810aidrm /etc/apt/sources.list.d/feng-kylin-*rm /var/lib/apt/lists/ppa.launchpad.net_feng-kylin_1810aid_ubuntu_dists_cosmic_*apt-get cleanrm /var/lib/apt/periodic/update-success-stampvim.tiny /etc/resolv.confvim.tiny /etc/apt/sources.listhistory -c 退出chroot前最后一个操作： 1234umount -l /sysumount -l /dev/ptsumount -l /devumount -l /proc 退出chroot环境: exit 删除旧的filesystem.squashfs，创建新的filesystem.squashfs，命令如下： 12sudo rm filesystem.squashfssudo mksquashfs squashfs-root/ filesystem.squashfs 更新filesystem.squashfs.size sudo du -sx --block-size=1 squashfs-root | cut -f1 &gt; filesystem.size 删除squashfs-root目录： 1sudo rm -r squashfs-root/ 将filesytem.squashfs 和filesystem.size移动到casper目录，并修改新filesystem.squashfs文件属主和权限，跟其余文件一样： 1234sudo mv filesystem.squashfs filesystem.size uk64/caspercd uk64/caspersudo chmod 444 filesystem.squashfs filesystem.sizesudo chown feng:feng filesystem.squashfs filesystem.size 定制ubiquity安装过程（可选）： 12sudo vim uk64/preseed/cli.seedsudo vim boot/grub/grub.cfg 修改bootlogo（可选）: 123456mv uk64/isolinux/bootlogo .mkdir bootlogo-tmp &amp;&amp; cd bootlogo-tmpcpio -i &lt; ../bootlogosudo vim txt.cfg lang langlistls -1 | cpio --quiet -o &gt; ./bootlogosudo cp * ../uk64/isolinux 进入到image-iso目录，更新md5值： 1234sudo rm md5sum.txtfind -type f -print0 | sudo xargs -0 md5sum | grep -v isolinux/boot.cat | sudo tee md5sum.txtsudo chown feng:feng md5sum.txtsudo chmod -w md5sum.txt 进入到uk64目录，压缩镜像 1xorriso -as mkisofs -r -checksum_algorithm_iso md5,sha1 -V Ubuntu-Kylin\\ 19.04 -o ubuntukylin-19.04-amd64.iso -isohybrid-mbr /usr/lib/ISOLINUX/isohdpfx.bin -cache-inodes -J -l -b isolinux/isolinux.bin -c isolinux/boot.cat -no-emul-boot -boot-load-size 4 -boot-info-table -eltorito-alt-boot -e boot/grub/efi.img -no-emul-boot -isohybrid-gpt-basdat -isohybrid-apm-hfsplus uk64/ 如果是32位: 1xorriso -as mkisofs -r -checksum_algorithm_iso md5,sha1 -V Ubuntu-Kylin\\ 18.04.2 -o ubuntukylin-18.04.2-enhanced-i386.iso -isohybrid-mbr /usr/lib/ISOLINUX/isohdpfx.bin -partition_offset 16 -cache-inodes -J -l -b isolinux/isolinux.bin -c isolinux/boot.cat -no-emul-boot -boot-load-size 4 -boot-info-table uk32/ 其他 pressed配置： https://help.ubuntu.com/lts/installation-guide/s390x/apbs04.html#preseed-l10n https://wiki.ubuntu.com/UbiquityAutomation https://help.ubuntu.com/community/InstallCDCustomization https://help.ubuntu.com/community/LiveCDCustomization https://help.ubuntu.com/community/LiveCDCustomizationFromScratch 修改/etc/sudoers,使得sudo不需要密码： kylin (ALL: ALL) NOPASSWD: ALL %sudo (ALL: ALL) NOPASSWD: ALL 解开initrd: unmkinitramfs initrd 自动化定制ISO工具： Cubic","tags":[],"categories":[{"name":"debian&ubuntu","slug":"debian-ubuntu","permalink":"https://handsome-feng.github.io/1night-cs/categories/debian-ubuntu/"}]},{"title":"deb包","date":"2020-05-22T12:03:32.768Z","path":"wiki/debian&ubuntu/deb/","text":"从源码构建deb包dh_make debuild 解包123456# 解包dpkg -X foo.deb extract/dpkg -e foo.deb extract/DEBIAN# 按需求修改# 打包dpkg-deb -b extract/ result/","tags":[],"categories":[{"name":"debian&ubuntu","slug":"debian-ubuntu","permalink":"https://handsome-feng.github.io/1night-cs/categories/debian-ubuntu/"}]},{"title":"Ubuntu","date":"2020-05-22T12:03:32.768Z","path":"wiki/debian&ubuntu/debian-ubuntu/","text":"本地准备工作: ~/.bashrc: 1234export DEBFULLNAME=&quot;handsome_feng&quot;export DEBEMAIL=&quot;jianfengli@ubuntukylin.com&quot;alias mylintian=&quot;lintian -i -EvIL +pedantic --verbose&quot;alias mylicensecheck=&quot;licensecheck -r . | grep -v &apos;UNKNOWN&apos;&quot; ~/. Ubuntu镜像下载MirrosPackages SearchSourceTesting trackerAutopkgtest seedshttps://wiki.ubuntu.com/UbuntuStudio/Seedshttps://wiki.ubuntu.com/SeedManagementhttps://wiki.ubuntu.com/Germinatehttps://wiki.ubuntu.com/ProposedMigrationhttp://people.canonical.com/~ubuntu-archive/seeds/http://people.canonical.com/~ubuntu-archive/germinate-output/Ubuntu中文WIKIUbuntu桌面指南Ubuntu认证硬件Debian新维护人员手册https://www.debian.org/doc/manuals/maint-guide/index.zh-cn.htmlhttps://www.debian.org/doc/manuals/maint-guide/Debian开发人员手册: https://www.debian.org/doc/manuals/developers-reference/Debian打包指南:https://www.debian.org/doc/manuals/packaging-tutorial/packaging-tutorial.en.pdfhttps://www.debian.org/doc/manuals/packaging-tutorial/packaging-tutorial.zh_TW.pdfhttp://packaging.ubuntu.com/html/Debian Policy Manuallintian tagsDaily build logUbuntu Autopkgtest ResultsTechnicalBoard:https://wiki.ubuntu.com/TechnicalBoardhttps://wiki.ubuntu.com/TechnicalBoardAgendaexcuses(proposed迁移): http://people.canonical.com/~ubuntu-archive/proposed-migration/update_excuses.htmlpackagesets: https://people.canonical.com/~ubuntu-archive/packagesets/bionic/License Information: https://ftp-master.debian.org/licenses/DeveloperMembershipBoard: https://wiki.ubuntu.com/DeveloperMembershipBoardUbuntu Developers: https://wiki.ubuntu.com/UbuntuDevelopers/TeamDelegationBugs/EmailInterface: https://help.launchpad.net/Bugs/EmailInterfaceLive filesystem information: https://launchpad.net/~ubuntu-cdimage/+livefs/ubuntu/cosmic/ubuntukylin/Debian bug-tracking system: https://debian-administration.org/article/436/Using_the_Debian_bug-tracking_systemdebian archive: https://salsa.debian.org/handsome_feng-guestDebian new and byhand pakcages: https://ftp-master.debian.org/new.htmlIrc logsReleasechangelogs 常用流程SponsorshipProcesshttps://wiki.ubuntu.com/SponsorshipProcess FFehttps://wiki.ubuntu.com/FreezeExceptionProcess 打包工具SBuild: https://wiki.ubuntu.com/SimpleSbuil 在线工具 在线贴图工具: https://imgur.com/在线贴文字工具: https://paste.ubuntu.com/ 在线gif制作: http://www.soogif.com/在线流程图: https://www.processon.com/diagrams 实用工具 Youcompleteme gollum irssi goldendict Beyond Compare SS xdotool X window 查看快捷键被谁捕获 1xdotool keydown \"shift+Print\"; xdotool key \"XF86LogGrabInfo\"; xdotool keyup \"Print\"; sleep 1; xdotool keyup \"shift\"; tail /var/log/Xorg.0.log 其他 ANSI控制码: http://ascii-table.com/ansi-escape-sequences.php","tags":[],"categories":[{"name":"debian&ubuntu","slug":"debian-ubuntu","permalink":"https://handsome-feng.github.io/1night-cs/categories/debian-ubuntu/"}]},{"title":"","date":"2020-05-22T12:03:32.768Z","path":"wiki/debian&ubuntu/grub/","text":"grub修复： 假如你的Ubuntu的 / 分区是sda9，又假如 /boot分区是 sda6，在终端下输入sudo -imount /dev/sda7 /mntmount /dev/sda6 /mnt/boot （如果没 /boot 单独分区这步跳过）grub-install –root-directory=/mnt/ /dev/sda做完后grub就修复了。 如果grub里没有windows的菜单了，那么进入Ubuntu系统，打开终端，重建GRUB列表 sudo update-grub重新写入第一分区mbr sudo grub-install /dev/sda","tags":[],"categories":[{"name":"debian&ubuntu","slug":"debian-ubuntu","permalink":"https://handsome-feng.github.io/1night-cs/categories/debian-ubuntu/"}]},{"title":"i18n/l10n","date":"2020-05-22T12:03:32.768Z","path":"wiki/debian&ubuntu/i18n-l10n/","text":"Gettext 1234gettext -o foo.pot //生成pot文件msginit --input=foo.pot --local=bo //生成bo.pomsgfmt bo.po -o bo.mo //生成momsgmerge foo_new.pot bo.po -o bo_new.po // 更具新的pot文件，更新po文件 1for po in `ls *.po`; do msgmerge -U $po slideshow-ubuntukylin.pot; done 修改po文件： 在Linux世界里有软件可以直接打开.mo文件以供编辑，这款软件叫——Virtaal 123msgunfmt foo.mo -o foo.po// Edit foo.pomsgfmt foo.po -o foo.mo qmakehello.pro 12TRANSLATIONS = zh_CN.ts \\ bo.ts 12lupdate -pro hello.prolrelease zh_CN.ts mesoni18n = import(‘i18n’)its_dir = xxxxi18n.merge_file( input: xxx output: xxx po_dir: xxx #data_dir: its_dir install: xx install_dir: xxx) in poi18n.gettext( meson.project_name(), preset: ‘glib’, #data_dirs: its_dir,)","tags":[],"categories":[{"name":"debian&ubuntu","slug":"debian-ubuntu","permalink":"https://handsome-feng.github.io/1night-cs/categories/debian-ubuntu/"}]},{"title":"How can I help","date":"2020-05-22T12:03:32.768Z","path":"wiki/debian&ubuntu/involve/","text":"Preparationsudo apt install how-can-i-help sudo apt install command-not-found Generic instructions: https://mentors.debian.net/intro-maintainersReintroducing packages: https://www.debian.org/doc/manuals/developers-reference/ch05.en.html#reintroducing-pkgs Report Bug12sudo apt install python3-gi-cairo gir1.2-vte-2.91reportbug --ui gtk2 The experimental repository123456deb http://deb.debian.org/debian experimental mainapt-get updateapt-get -t experimental install packagename//listing all packages installed from experimentalaptitude search ~S~i~Aexperimental Debian version numbering The format is: [epoch:]upstream_version[-debian_revision] The three components here are: epochThis is a single (generally small) unsigned integer. It may be omitted, in which case zero is assumed. If it is omitted then the upstream_version may not contain any colons. It is provided to allow mistakes in the version numbers of older versions of a package, and also a package’s previous version numbering schemes, to be left behind. upstream_versionThis is the main part of the version number. It is usually the version number of the original (“upstream”) package from which the .deb file has been made, if this is applicable. Usually this will be in the same format as that specified by the upstream author(s); however, it may need to be reformatted to fit into the package management system’s format and comparison scheme.The comparison behavior of the package management system with respect to the upstream_version is described below. The upstream_version portion of the version number is mandatory.The upstream_version may contain only alphanumerics[36] and the characters “.” (full stop), “+” (plus), “-“ (hyphen), “:” (colon), “~” (tilde) and should start with a digit. If there is no debian_revision then hyphens are not allowed; if there is no epoch then colons are not allowed. debian_revisionThis part of the version number specifies the version of the Debian package based on the upstream version. It may contain only alphanumerics and the characters “.” (full stop), “+” (plus), “~” (tilde) and is compared in the same way as the upstream_version is.It is optional; if it isn’t present then the upstream_version may not contain a hyphen. This format represents the case where a piece of software was written specifically to be a Debian package, where the Debian package source must always be identical to the pristine source and therefore no revision indication is required.It is conventional to restart the debian_revision at 1 each time the upstream_version is increased.The package management system will break the version number apart at the last hyphen in the string (if there is one) to determine the upstream_version and debian_revision. The absence of a debian_revision is equivalent to a debian_revision of 0. ComparisonWhen comparing two version numbers, first the epoch of each are compared, then the upstream_version if epoch is equal, and then debian_revision if upstream_version is also equal. epoch is compared numerically. The upstream_version and debian_revision parts are compared by the package management system using the following algorithm:The strings are compared from left to right.First the initial part of each string consisting entirely of non-digit characters is determined. These two parts (one of which may be empty) are compared lexically. If a difference is found it is returned. The lexical comparison is a comparison of ASCII values modified so that all the letters sort earlier than all the non-letters and so that a tilde sorts before anything, even the end of a part. For example, the following parts are in sorted order from earliest to latest: , ~a, ~, the empty part, a.Then the initial part of the remainder of each string which consists entirely of digit characters is determined. The numerical values of these two parts are compared, and any difference found is returned as the result of the comparison. For these purposes an empty string (which can only occur at the end of one or both version strings being compared) counts as zero.These two steps (comparing and removing initial non-digit strings and initial digit strings) are repeated until a difference is found or both strings are exhausted.Note that the purpose of epochs is to allow us to leave behind mistakes in version numbering, and to cope with situations where the version numbering scheme changes. It is not intended to cope with version numbers containing strings of letters which the package management system cannot interpret (such as ALPHA or pre-), or with silly orderings. ubuntu will indicate that the package has been built specifically for Ubuntu. The alpha and build strings don’t seem to have any particular meaning, but dfsg refers to a package that has been modified for compliance with the Debian Free Software Guidelines. Prepare patches for Debian package1. Retrieve the source package and install build-dependenciesThe first step is to retrieve the latest version of the source package and to install the required build-dependencies. If you prefer, you can use dget (from the devscripts package) to directly grab the source package. You can find the URL of the .dsc files in the Package Tracking System for example. you can use debcheckout to retrieve the VCS repository instead (provided that you have the corresponding VCS installed): 1234$ debcheckout wordpressdeclared git repository at git://git.debian.org/git/collab-maint/wordpress.gitgit clone git://git.debian.org/git/collab-maint/wordpress.git wordpress ...Cloning into wordpress... It’s also a good idea to install the package “packaging-dev”. It’s a meta-package depending on the most common tools that are used for Debian packaging work. 2. Do the changesExecute dch –nmu to record the fact that you’re working on an update prepared by someone who is not the maintainer (NMU means Non Maintainer Upload). This also ensures that if we build the package, we won’t overwrite the original source package that we downloaded, thus making it possible to generate a “diff” between both versions. 2.1. Modify Debian packaging filesNow fire your text editor and do the required changes in the “debian” sub-directory. You will probably run dch -a multiple times to document each subsequent change. 2.2. Modify upstream filesIf you have to modify upstream files, the proper way to do it depends on the source package format (“1.0” vs “3.0 (quilt)” vs “3.0 (native)”, see the debian/source/format file) and on the presence or not of a patch system (the what-patch can help you identify it). In this explanation, I’ll assume that the package is using the recommended format: “3.0 (quilt)”. (It also works for “1.0” if quilt is used and if you configured ~/.quiltrc as recommended by /usr/share/doc/quilt/README.source). First you should ensure that all patches have been applied with quilt push -a. If there’s no patch yet, you want to create the debian/patches directory (with mkdir debian/patches). Note that you should better invoke quilt from the root of the source package (and the examples below assume this). 2.2.1 Import a patchIf the upstream changes are already in a patch file (say /tmp/patch that you downloaded from the upstream VCS repository) you can import that patch like this: $ quilt import -P fix-foobar.patch /tmp/patchImporting patch /tmp/patch (stored as fix-foobar.patch)$ quilt pushApplying patch fix-foobar.patch[…]Now at patch fix-foobar.patchThe -P option allows to select the name of the patch file created in debian/patches/. As you see, the new patch file is recorded in debian/patches/series but not applied by default, we’re thus doing it with quilt push. 2.2.2. Create a new patchIf the upstream changes that you want to make are not in a patch yet, you should tell quilt that you’re going to create one: $ quilt new fix-foobar.patchPatch fix-foobar.patch is now on topThen you must record every file that you’re going to modify with a quilt add invocation. quilt then makes a backup of those files so that it can generate the patch later on. If you’re going to modify the files with your text editor you can just do quilt edit file-to-modify, it’s the same than quilt add file-to-modify followed by sensible-editor file-to-modify. $ quilt edit foobar.cFile foobar.c added to patch fix-foobar.patchThe last step is tell quilt to generate the patch: $ quilt refreshRefreshed patch fix-foobar.patch 2.2.3 Patch HeadersWe recommend that you tag every patch with DEP-3 headers by putting them at the top of patch file. Here are some headers that you can use: Description: Description of what the patch does. It is formatted like Description field in debian/control: first line is short description, starting with lowercase letter, the next lines are long description, indented with a space.Author: Who wrote the patch (i.e. “Jane Doe &#x70;&#97;&#x63;&#x6b;&#97;&#x67;&#x65;&#x72;&#64;&#x65;&#x78;&#x61;&#109;&#112;&#x6c;&#101;&#x2e;&#x63;&#111;&#x6d;”).Origin: Where this patch comes from (i.e. “upstream”), when Author is not present.Bug-Ubuntu: A link to Launchpad bug, a short form is preferred (like https://bugs.launchpad.net/bugs/XXXXXXX). If there are also bugs in upstream or Debian bugtrackers, add Bug or Bug-Debian headers.Forwarded: Whether the patch was forwarded upstream. Either “yes”, “no” or “not-needed”.Last-Update: Date of the last revision (in form “YYYY-MM-DD”). 3. Test your changesYou should build your modified package with “debuild -us -uc”. You can easily install the resulting package with “debi”. Verify that everything works as expected. If not, continue your modifications until you’re satisfied with the result. 4. Generate a patch and mail itIf you followed the instructions, you should have two .dsc files in the parent directory, like this: 1234$ cd ..$ ls wordpress_*.dsc../wordpress_3.0.5+dfsg-1.1.dsc../wordpress_3.0.5+dfsg-1.dsc Generating the patch to send to the maintainer is then just a matter of running debdiff: 1$ debdiff wordpress_3.0.5+dfsg-1.dsc wordpress_3.0.5+dfsg-1.1.dsc &gt;/tmp/wp-debdiff You can send the /tmp/wp-debdiff file to the wordpress maintainer. Usually you send it via the bugreport that your update is fixing and you add the “patch” tag to the report. This can be automated with the nmudiff utility. By default it assumes that you’re using mutt but it can also directly feed the resulting mail to sendmail. The default text that nmudiff proposes assumes that you’re actually performing an NMU and that the result has been uploaded. If that’s not the case, you should edit the text and make it clear that you’re just sending a patch. Tag the bug as “patch available” by running 1bts tags [bugnumber] + patch","tags":[],"categories":[{"name":"debian&ubuntu","slug":"debian-ubuntu","permalink":"https://handsome-feng.github.io/1night-cs/categories/debian-ubuntu/"}]},{"title":"","date":"2020-05-22T12:03:32.768Z","path":"wiki/debian&ubuntu/license/","text":"gbp import-orig –uscan tar -t -a -f /tmp/gmsh-4.5.2-source.tgz https://wiki.debian.org/CopyrightReviewTools licensecheck –check ‘.*’ –recursive –deb-machine –lines 0 *","tags":[],"categories":[{"name":"debian&ubuntu","slug":"debian-ubuntu","permalink":"https://handsome-feng.github.io/1night-cs/categories/debian-ubuntu/"}]},{"title":"","date":"2020-05-22T12:03:32.768Z","path":"wiki/debian&ubuntu/packaging/","text":"git-deborig pristine-tar tag2upload origtargz dgit –gbp sbuild dgit –gbp push-source 1cme update dpkg-copyright","tags":[],"categories":[{"name":"debian&ubuntu","slug":"debian-ubuntu","permalink":"https://handsome-feng.github.io/1night-cs/categories/debian-ubuntu/"}]},{"title":"Pbuilder","date":"2020-05-22T12:03:32.768Z","path":"wiki/debian&ubuntu/pbuilder/","text":"Installsudo apt install pbuilder qemu-user-static Setup Add following contents to /etc/pbuilderrc: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081# Codenames for Debian suites according to their alias. Update these when needed.UNSTABLE_CODENAME=\"sid\"TESTING_CODENAME=\"bullseye\"STABLE_CODENAME=\"buster\"STABLE_BACKPORTS_SUITE=\"$STABLE_CODENAME-backports\"# List of Debian suites.DEBIAN_SUITES=($UNSTABLE_CODENAME $TESTING_CODENAME $STABLE_CODENAME \"unstable\" \"testing\" \"stable\")# List of Ubuntu suites. Update these when needed.UBUNTU_SUITES=(\"focal\" \"bionic\" \"xenial\")# Mirrors to use. Update these to your preferred mirror.DEBIAN_MIRROR=\"ftp.cn.debian.org\"UBUNTU_MIRROR=\"ftp.ubuntu.com\"# Optionally use the changelog of a package to determine the suite to use if none set.if [ -z \"$&#123;DIST&#125;\" ] &amp;&amp; [ -r \"debian/changelog\" ]; then DIST=$(dpkg-parsechangelog | awk '/^Distribution: / &#123;print $2&#125;') DIST=\"$&#123;DIST%%-*&#125;\" # Use the unstable suite for certain suite values. if $(echo \"experimental UNRELEASED\" | grep -q $DIST); then DIST=\"$UNSTABLE_CODENAME\" fifi# Optionally set a default distribution if none is used. Note that you can set your own default (i.e. $&#123;DIST:=\"unstable\"&#125;).: $&#123;DIST:=\"$(lsb_release --short --codename)\"&#125;# Optionally change Debian release states in $DIST to their names.case \"$DIST\" in unstable) DIST=\"$UNSTABLE_CODENAME\" ;; testing) DIST=\"$TESTING_CODENAME\" ;; stable) DIST=\"$STABLE_CODENAME\" ;;esac# Optionally set the architecture to the host architecture if none set. Note that you can set your own default (i.e. $&#123;ARCH:=\"i386\"&#125;).: $&#123;ARCH:=\"$(dpkg --print-architecture)\"&#125;NAME=\"$DIST\"if [ -n \"$&#123;ARCH&#125;\" ]; then NAME=\"$NAME-$ARCH\" DEBOOTSTRAPOPTS=(\"--arch\" \"$ARCH\" \"$&#123;DEBOOTSTRAPOPTS[@]&#125;\")fiBASETGZ=\"/var/cache/pbuilder/$NAME-base.tgz\"# Optionally, set BASEPATH (and not BASETGZ) if using cowbuilder# BASEPATH=\"/var/cache/pbuilder/$NAME/base.cow/\"DISTRIBUTION=\"$DIST\"BUILDRESULT=\"/var/cache/pbuilder/$NAME/result/\"APTCACHE=\"/var/cache/pbuilder/$NAME/aptcache/\"BUILDPLACE=\"/var/cache/pbuilder/build/\"if $(echo $&#123;DEBIAN_SUITES[@]&#125; | grep -q $DIST); then # Debian configuration MIRRORSITE=\"http://$DEBIAN_MIRROR/debian/\" COMPONENTS=\"main contrib non-free\" DEBOOTSTRAPOPTS=(\"$&#123;DEBOOTSTRAPOPTS[@]&#125;\" \"--keyring=/usr/share/keyrings/debian-archive-keyring.gpg\")elif $(echo $&#123;UBUNTU_SUITES[@]&#125; | grep -q $DIST); then # Ubuntu configuration MIRRORSITE=\"http://$UBUNTU_MIRROR/ubuntu/\" COMPONENTS=\"main restricted universe multiverse\" DEBOOTSTRAPOPTS=(\"$&#123;DEBOOTSTRAPOPTS[@]&#125;\" \"--keyring=/usr/share/keyrings/ubuntu-archive-keyring.gpg\")else echo \"Unknown distribution: $DIST\" exit 1fi Hook Copy the hook you want from /usr/share/doc/pbuilder/examples/ to a directory: 12mkdir ~/pbuilderhookscp /usr/share/doc/pbuilder/examples/B90lintian ~/pbuilderhooks Modify the hooks to satisfied our demands: Change the lintian segments from: su -C &quot;lintian -I --show-overrides &quot;$BUILDDIR&quot;/.change; - pbuilder to su -C &quot;lintian -i -EvIL +pedantic --verbose &quot;$BUILDDIR&quot;/*.changes&quot; - pbuilder Then tell pbuilder to user the hooks in that directory: 1echo \"HOOKDIR=$HOME/pbuilderhooks/\" | sudo tee -a /etc/pbuilderrc Customize the chroot environment123sudo pbuilder --login --save-after-login --basetgz &lt;path to your base.tgz file&gt;# if ARCH=i386 pdebuild failedsudo pbuilder --login --bindmounts ukui-window-switch Note down the temporary build directory root which you can use to copy files to and from. For example, 123456789101112131415$ sudo pbuilder --loginI: Building the build EnvironmentI: extracting base tarball [/media/forge/debian/pbuilder/sid-base.tgz]I: creating local configurationI: copying local configurationI: mounting /proc filesystemI: mounting /run/shm filesystemI: mounting /dev/pts filesystemI: Mounting /media/forge/debian/pbuilder/ccacheI: policy-rc.d already existsI: Obtaining the cached apt archive contentsI: entering the shellFile extracted to: /media/forge/debian/pbuilder/build/26975root@savannah:/# Your debian environment is at /media/forge/debian/pbuilder/build/26975. Any file you copy there will be available to debian chroot. Multi-archIf use pbuilder-dist: 12pbuilder-dist unstable armhf createpbuilder-dist unstable armhf bb_1.3rc1-8.3.dsc Manually doing what pbuilder-dist can do: 1234567891011121314151617#Create a base environment for Debian sidsudo DIST=sid pbuilder create#Create a base environment for Ubuntu eoan under the i386 architecturesudo DIST=eoan ARCH=i386 pbuilder create#Create a base environment for Ubuntu eoansudo DIST=eoan pbuilder create#Update a base environment for Ubuntu eoansudo DIST=eoan pbuilder update#Build a package using Ubuntu eoan as the base environmentDIST=eoan pdebuild#Build a package using Ubuntu eoan as the base environment under the i386 architectureDIST=eoan ARCH=i386 pdebuild Referencehttps://wiki.ubuntu.com/PbuilderHowto https://wiki.debian.org/PbuilderTricks https://pbuilder-docs.readthedocs.io/en/latest/index.html","tags":[],"categories":[{"name":"debian&ubuntu","slug":"debian-ubuntu","permalink":"https://handsome-feng.github.io/1night-cs/categories/debian-ubuntu/"}]},{"title":"seeds","date":"2020-05-22T12:03:32.768Z","path":"wiki/debian&ubuntu/seeds/","text":"cd ~/home/feng/seeds git clone git clone mv ubuntukylin ubuntukylin.disco mv platform platform.disco germinate -S file:///home/feng/seeds/ -s ubuntukylin.disco -d disco -a amd64 -c main,restricted,universe,multiverse -m http://mirrors.aliyun.com/ubuntu/ 最后查看desktop文件，为桌面版本iso的包列表 This is an example of a seed file (minimized version of a real seed file): 1234567891011121314151617Task-Per-Derivative: 1Task-Section: userTask-Description: 2D/3D creation and editing suiteTask-Key: ubuntustudio-graphics* agave #This is a dependency* (blender) #This is a recommend# * (openclipart-svg) #Has been commented out, and will not be used* ubuntukylin-desktop # Metapackage for everything here. You can view the current seeds, and the current output of germinate. refefence: https://wiki.ubuntu.com/SeedManagement https://wiki.ubuntu.com/Germinate","tags":[],"categories":[{"name":"debian&ubuntu","slug":"debian-ubuntu","permalink":"https://handsome-feng.github.io/1night-cs/categories/debian-ubuntu/"}]},{"title":"symbols files","date":"2020-05-22T12:03:32.768Z","path":"wiki/debian&ubuntu/symbols/","text":"Symbols files provide a way of tracking the exported symbols of a library, which helps in fine-tuning the library dependencies generated by dpkg-shlibdeps and tracking (partially) binary compatibility. Using symbolshelper in your package add pkg-kde-tools to your Build-Depends change the debian/rules file: 12%: dh $@ --with pkgkde_symbolshelper Creating a symbols file build the package run the follow commands: 12pkgkde-gensymbols -plibfoo1 -v1.7 -Osymbols.amd64 -edebian/libfoo1/usr/lib/libfoo.so.1pkgkde-symbolshelper create -o debian/libfoo1.symbols -v 1.7 symbols.amd64 Updating multiple symbols filesIn source packages that provide multiple binary library packages: pkgkde-symbolshelper batchpatch -v 1.8 buildlog You can get the symbols for different archs including those from www.ports.debian.org all at once by running inside the top-level source directory the getbuildlog script as provided by the devscripts package: getbuildlog peony last pkgkde-symbolshelper batchpatch -v 1.8 foo_1.8-1*.build reference: https://qt-kde-team.pages.debian.net/symbolfiles.html","tags":[],"categories":[{"name":"debian&ubuntu","slug":"debian-ubuntu","permalink":"https://handsome-feng.github.io/1night-cs/categories/debian-ubuntu/"}]},{"title":"sync and merge","date":"2020-05-22T12:03:32.768Z","path":"wiki/debian&ubuntu/sync-merge/","text":"Sync Request Process syncpackage -V 2.0.3-1 ukui-menu Merging Ubuntu Merge-o-Matic","tags":[],"categories":[{"name":"debian&ubuntu","slug":"debian-ubuntu","permalink":"https://handsome-feng.github.io/1night-cs/categories/debian-ubuntu/"}]},{"title":"","date":"2020-05-22T12:03:32.768Z","path":"wiki/debian&ubuntu/uploadQueue/","text":"Upload to the queue: dput ukui-menu_2.0.3-1_source.changes Remove from the upload queue: dcut –input ukui-menu_2.0.3-1_source.changes","tags":[],"categories":[{"name":"debian&ubuntu","slug":"debian-ubuntu","permalink":"https://handsome-feng.github.io/1night-cs/categories/debian-ubuntu/"}]},{"title":"Debugging Procedures","date":"2020-05-22T12:03:32.768Z","path":"wiki/debug/DebugginProcedures/","text":"https://wiki.ubuntu.com/DebuggingProcedures Info for the BugSquad This will create a minimal Precise system: 12sudo mkdir -p /chroots/precisesudo debootstrap precise /chroots/precise/ Now change into this minimal precise system: 1sudo chroot /chroots/precise Edit /etc/apt/sources/list and add all the repositories you need, including the ddeb repository. Execute the following in a terminal: 1sudo apt-get update; sudo apt-get install gdb apport use apport-retrace as you’re used to. Compiling with debugging -g option123./autogen.sh./configure CFLAGS=\"-g -O0\" #option A./configure --enable-debug #option B strace12$ strace ./a.out //察看程序在执行什么系统调用$ strace -p pid //附到一个已经在跑的进程上，实时观察 mtracevalgrindhttps://wiki.ubuntu.com/Valgrind BacktraceGeneration Please ensure you have packages with debug symbols installed. You can do this by following the instructions at DebuggingProgramCrash. Make sure the GNU Debugger is installed. sudo apt-get install gdbStart the program under control of gdb via a terminal (some programs run as root, so one would use sudo gdb instead of just gdb below): 1234gdb &lt;program&gt; 2&gt;&amp;1 | tee ~/gdb-&lt;program&gt;.txt(gdb) handle SIG33 pass nostop noprint(gdb) set pagination 0(gdb) run &lt;arguments, if any&gt; The program will start. Perform any actions necessary to reproduce the crash. If the program hangs but doesn’t crash you can press ctrl+c in gdb while the program is frozen and then continue with the next step.Retrieve a backtrace: 12345(gdb) backtrace full(gdb) info registers(gdb) x/16i $pc(gdb) thread apply all backtrace(gdb) quit Attach the complete output from GDB, contained in gdb-.txt, in your bug report. You will find the file in your home directory /home//. 察看进程占用IO命令只显示有I/O行为的进程 $ iotop -oP 查看特定进程 $ iotop -p $PID 展示I/O统计,每秒更新一次 $ pidstat -d 1 查看该进程启动的完整命令行 $ ps eho command -p $PID 查看该进程启动时候所在的目录 $ readlink /proc/$PID/cwd 查看该进程启动时的完整环境变量 strings -f /proc/$PID/environ | cut -f2 -d ” 列出该进程所打开的所有文件: $ lsof -p $PID cwd代表当前目录,这里是/root rtd代表根目录,这里是/ txt代表执行的程序,这里是/bin/bash mem代表映射到内存的文件,这里是/lib/libc-2.7.so等动态链接库 TYPE一栏表示文件/目录的类型,DIR代表目录,REG代表普通文件,CHR代表字符设备.列出该进程所打开的网络连接: $ netstat -pan | grep $PID 查看文件被哪个i进程占用 $ sudo fuser -v path/to/file $ lsof path/to/file 察看多线程所有线程ID$ ps -T$ top -H -p &lt;pid&gt; //让top输出某个特定进程并检查该进程内运行的线程状况$ htop 监控文件audit inotifywait inotifymoniter PSTo print a process tree: 12ps -ejHps axjf To get info about threads: 12ps -eLfps axms To get security info: 123ps -eo euser,ruser,suer,fuser,f,comm,labelps axZps -eM To see every process running as root (real &amp; effective ID) in user format: 1ps -U root -u root u To see every process with a user-defined format: 123ps -eo pid,tid,class,rtprio,ni,pri,psr,pcpu,stat,wchan:14,commps axo stat,euid,ruid,tty,tpgid,sess,pgrp,ppid,pid,pcpu,commps -Ao pid,tt,user,fname,tmout,f,wchan Print only the process IDs of syslogd: 1ps -C syslogd -o pid= Print only the name of PID 42: 1ps -q 42 -o comm=","tags":[],"categories":[{"name":"debug","slug":"debug","permalink":"https://handsome-feng.github.io/1night-cs/categories/debug/"}]},{"title":"Doxygen + graphviz","date":"2020-05-22T12:03:32.768Z","path":"wiki/debug/Doxygen/","text":"简介doxygenDoxygen is the de facto standard tool for generating documentation from annotated C++ sources, but it also supports other popular programming languages such as C, Objective-C, C#, PHP, Java, Python, IDL (Corba, Microsoft, and UNO/OpenOffice flavors), Fortran, VHDL, Tcl, and to some extent D. graphvizGraphviz is open source graph visualization software. Graph visualization is a way of representing structural information as diagrams of abstract graphs and networks. It has important applications in networking, bioinformatics, software engineering, database and web design, machine learning, and in visual interfaces for other technical domains. 安装1$ sudo apt install doxygen doxygen-gui grahpviz 使用1$ doxywizard 注释规则doxygen并不能随便读取你的C++的注释,必须按照一定的规则才能生成 参考https://www.jianshu.com/p/fe4b6b95dca5","tags":[],"categories":[{"name":"debug","slug":"debug","permalink":"https://handsome-feng.github.io/1night-cs/categories/debug/"}]},{"title":"Debug Symbol Pakcages","date":"2020-05-22T12:03:32.768Z","path":"wiki/debug/dbgsym/","text":"Debug Symbol Packages Create an /etc/apt/sources.list.d/ddebs.list by running the following line at a terminal: 12345# for ubuntuecho \"deb http://ddebs.ubuntu.com $(lsb_release -cs) main restricted universe multiversedeb http://ddebs.ubuntu.com $(lsb_release -cs)-updates main restricted universe multiversedeb http://ddebs.ubuntu.com $(lsb_release -cs)-proposed main restricted universe multiverse\" | \\sudo tee -a /etc/apt/sources.list.d/ddebs.list 12345678# for debiandeb http://deb.debian.org/debian-debug/ stable-debug maindeb http://deb.debian.org/debian-debug/ proposed-updates-debug maindeb http://deb.debian.org/debian-debug/ stretch-backports-debug maindeb http://deb.debian.org/debian-debug/ testing-debug maindeb http://deb.debian.org/debian-debug/ testing-proposed-updates-debug maindeb http://deb.debian.org/debian-debug/ unstable-debug maindeb http://deb.debian.org/debian-debug/ experimental-debug main Import the debug symbol archive signing key from the Ubuntu server: 12$ sudo apt install ubuntu-dbgsym-keyring $ sudo apt update Install debug packages 1$ sudo apt install xxx-dbgsym Automatic resolution 使用debian-goodies获取需要安装的所有dbgsym包 12apt install debian-goodiesfind-dbgsym-packages [core_path|running_pid|binary_path] 或者通过以下脚本(此脚本年久失修，需要更新) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#!/bin/bash -xprogname=`basename \"$0\"`explain() &#123; cat &lt;&lt; EOFUsage: $progname [-adt] [-p pid] | [exectable]You must specify a pid (-p) or an executable name/path.This scripts list the dbug symbols packages you need to install for a complete dump of the give executable. Already installed symbols packages are not shown.Options are: -p pid uses the running process with the given pid to get the list. If specified, you may omit the executable name. -a show all the required symbol packages (not only the not-installed ones) -d prefer XXX-dbg symbol packages over XXX-dbgsym ones -t terse: print the packages names only (no package description). Useful to pass output directly to apt-get install.NOTE: in some cases $progname may report already installedpackages. This currently happens with binaries using libpthread.so aslibc6-i686-dbgsym apparently doesn't contain debug symbols for it.To examine a running server process by pid, you will need to run this scriptusing sudo.EOF exit -1&#125;all=falsepreferred=\"dbgsym dbg\"debug=falseterse=falsepid=while getopts :adgp:t opt; do case $opt in a) all=true ;; d) preferred=\"dbg dbgsym\" ;; g) debug=true ;; p) pid=\"$OPTARG\" binary=$(readlink /proc/$pid/exe) [ -z \"$binary\" ]&amp;&amp; echo \"Unable to get binary path for pid $pid\" &amp;&amp; exit -1 t) terse=true ;; \\?) explain ;; esacdoneif [ -z \"$binary\" ]; then shift $(( $OPTIND - 1 )) [ $# -ne 1 ] &amp;&amp; explain binary=\"$1\" [ ! -x \"$binary\" -a `basename @\"$binary\"` = @\"$binary\" -a -n \"`which $binary`\" ] &amp;&amp; binary=`which $binary`fifind-debug() &#123; while read i; do for ext in $preferred; do i=$(echo \"$i\"|cut -f 1 -d:) #remove the architecture suffix apt-cache search \"^$i-$ext\\$\" done |head -1 done&#125;if [ ! -z \"$pid\" ]; then Args=\"--pid=$pid\"else Args=\"$binary\"fiecho q| gdb \"$Args\" | \\grep 'Reading symbols from '| \\if $all; then cat; else grep 'no debugging symbols found'; fi | \\sed -e 's/^Reading symbols from \\(.*\\)\\.\\.\\.\\((\\|Reading \\).*$/\\1/' | \\while read i; do \\ #dpkg -S \"$i\" |while read j; do if $debug; then echo '!' $i '--&gt;' $j 1&gt;&amp;2; fi; echo $j; done ( if ! dpkg -S \"$i\" 2&gt;/dev/null; then [ -L \"$i\" ] &amp;&amp; dpkg -S `readlink \"$i\"`; fi ) | \\ while read j; do if $debug; then echo '!' $i '--&gt;' $j 1&gt;&amp;2; fi; echo $j; done \\done| sed -e 's/^\\(.*\\): .*$/\\1/' | sort -u | \\find-debug | if $terse; then sed -e 's/ - .*$//'; else cat; fi |sort -u Set generate core dump: 12345ulimit -c unlimited# Ubuntu set /proc/sys/kernel/core_pattern to 'apport /usr/share/apport/apport %p %s %c %p', so stop it first.sudo service apport stop# Set the location of coredump file.sudo sysctl -w kernel.core_pattern=/tmp/core-%e.%p.%h.%t or set these properties permanently: 123456# edit /etc/security/limits.conf* soft core unlimitedroot soft core unlimited# edit /etc/sysctl.conf and make it effectivekernle.core_pattern=/tmp/core-%e.%p.%h.%tsysctl -p You can install systemd-coredump to control dump file deeply. gdb ./a.out core Debianhttps://wiki.debian.org/AutomaticDebugPackages Principle/usr/lib/.build-id contains the main build-id files for installed packages. Debug info packages are used in many distributions to provide a way for users to install debugging information when necessary, without bloating binaries for everyone. When a program or library is built and linked, it can be built with debugging information, which debuggers can then use to map locations in the binary with locations in its source code; but this information takes up a lot of room. So debugging information is typically stripped from binaries before they’re packaged. In recent years, strip and objcopy have been enhanced so that debugging information can be extracted and stored separately — that’s how debug info packages are built. All that’s needed then is some way of ensuring that a binary and its debug information correspond, and that’s where build ids come in — they are unique identifiers calculated by ld (look for --build-id there) over the significant portions of a binary. “Main build-id files” are symlinks from a build id to the corresponding binary or debug info file; they allow two-way mappings to be implemented, so that core dumps can be usefully debugged (there’s a link from binaries to their build ids in the binaries themselves, in the .gnu_debuglink section). You’ll find a detailed explanation of the reasoning behind all this in the Fedora build-id feature description. 123456789101112$ readelf -S ukui-indicators //没啥用[28] .gnu_debuglink PROGBITS 0000000000000000 0001b0f4 0000000000000034 0000000000000000 0 0 4 $ dpkg -L ukui-indicators-dbgsym /usr/lib/debug/.build-id/04/165df8cff97ce4a70ce9cb3738812bcee72c07.debug $ readelf -all ukui-indicators Displaying notes found in: .note.gnu.build-id 所有者 Data size Description GNU 0x00000014 NT_GNU_BUILD_ID (unique build ID bitstring) Build ID: 04165df8cff97ce4a70ce9cb3738812bcee72c07","tags":[],"categories":[{"name":"debug","slug":"debug","permalink":"https://handsome-feng.github.io/1night-cs/categories/debug/"}]},{"title":"Gdb","date":"2020-05-22T12:03:32.768Z","path":"wiki/debug/gdb/","text":"gdb调试12345678910111213141516171819$ b main //设置断点$ info b //显示断点$ delte 3 //删除断点，基于断点号$ delete 1-3$ clear mythrad1 //删除断点基于文件或行号$ clear myThread.c :mythread1$ info threads //显示线程$ thread 2 //切换到线程2$ set scheduler-locking on //只调试当前线程$ step //单步调试，跟踪$ bt //查看当前所有栈信息$ frame //查看当前栈（当前执行的源码在哪一行）$ info locals //显示所有局部变量$ print xx //显示变量xx的值 $ watch n //监控n的值，有变化时显示出来$ file /home/feng/a.out //载入新的symbol table$ attach pid //附到一个已经在跑的进程上(需要root权限)$ info inferiors //查询正在调试的进程$ dir path/to/source 1$ set follow-fork-mode [parent|child] set detach-on-fork [on|off] //调试多进程 follow-fork-mode detach-on-fork 说明 parent on 只调试主进程（GDB默认） child on 只调试子进程 parent off 同时调试两个进程，gdb跟主进程，子进程block在fork位置 child off 同时调试两个进程，gdb跟子进程，主进程block在fork位置 set target-async on set pagination off set non-stop on","tags":[],"categories":[{"name":"debug","slug":"debug","permalink":"https://handsome-feng.github.io/1night-cs/categories/debug/"}]},{"title":"Vargrind quick start quide","date":"2020-05-22T12:03:32.768Z","path":"wiki/debug/vargrind/","text":"Preparing your programCompile with -g -O0 Runningvalgrind –leak-check=yes –track-origins=yes myprog arg1 arg2","tags":[],"categories":[{"name":"debug","slug":"debug","permalink":"https://handsome-feng.github.io/1night-cs/categories/debug/"}]},{"title":"","date":"2020-05-22T12:03:32.768Z","path":"wiki/design-pattern/design-pattern/","text":"单例模式12345678910111213141516# python装饰器实现def Singleton(cls): _instance = &#123;&#125; def _singleton(*args, **kwargs): if cls not in _instance: _instance[cls] = cls(*args, **kwargs) return _instance[cls] return _singleton@Singletonclass A(object): def __init__(self, x): self.x = x 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// c++实现//Singleton.h#ifndef _SINGLETON_H_#define _SINGLETON_H_class Singleton&#123;public: static Singleton* getInstance();private: Singleton(); //把复制构造函数和=操作符也设为私有,防止被复制 Singleton(const Singleton&amp;); Singleton&amp; operator=(const Singleton&amp;); static Singleton* instance;&#125;;#endif // Singleton.cpp#include \"Singleton.h\"Singleton::Singleton()&#123;&#125;Singleton::Singleton(const Singleton&amp;)&#123;&#125;Singleton&amp; Singleton::operator=(const Singleton&amp;)&#123;&#125;//在此处初始化Singleton* Singleton::instance = new Singleton();Singleton* Singleton::getInstance()&#123; return instance;&#125; // main.c#include \"Singleton.h\"#include &lt;stdio.h&gt;int main()&#123; Singleton* singleton1 = Singleton::getInstance(); Singleton* singleton2 = Singleton::getInstance(); if (singleton1 == singleton2) fprintf(stderr,\"singleton1 = singleton2\\n\"); return 0;&#125; 创建型模式简单工厂模式在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。 简单工厂模式包含如下角色： Factory：工厂角色 工厂角色负责实现创建所有实例的内部逻辑 Product：抽象产品角色 抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口 ConcreteProduct：具体产品角色 具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。 123456789101112131415161718192021class Mercedes(object): def __repr__(self): return \"Mercedes-Bens\"class BMW(object): def __repr__(self): return \"BMW\"# beforemercedes = Mercedes()bmw = BMW()# afterclass SimpleFactory(object): def product_car(name): if name == 'mb': return Mercedes() elif name == 'bmw': return BMW()c1 = SimpleFactory.product_car('mb')c2 = SimpleFactory.product_car('bmw') 工厂方法模式工厂方法模式是简单工厂的仅一步深化， 在工厂方法模式中，我们不再提供一个统一的工厂类来创建所有的对象，而是针对不同的对象提供不同的工厂。也就是说每个对象都有一个与之对应的工厂。 12345678910111213141516171819202122import abcclass AbstractFactory(object): __metaclass__ = abc.ABMMeta @abc.abstractmethod def product_car(self): passclass MercedesFactory(AbstractFactory): def product_car(self): return Mercedes()class BMWFactory(AbstractFactory): def product_car(self): return BMW()# before: 新增一个car，需要修改工厂的代码# after: 新增一个car，只要增加相应的工厂c1 = MercedesFactory().product_car()c2 = BMWFactory().product_car() 抽象工厂模式抽象工厂模式是工厂方法的进一步深化，在这个模式中的工厂类不单单可以创建一个对象，而是可以创建一组对象。 123456789101112131415161718192021222324252627282930313233343536373839404142import abcclass Mercedes_C63(object): def __repr__(self): return \"Mercedes-Benz: C63\"class BMW_M3(object): def __repr__(self): return \"BMW: M3\"class Mercedes_G63(object): def __repr__(self): return \"Mercedes_Bens: G63\"class BMW_X5(object): def __repr__(self): return \"BMW: X5\"class AbstractFactory(object): __metaclass__ = abc.ABCMeta @abc.abstractmethod def product_car(self): pass @abc.abstractmethod def product_suv(self): passclass MercedesFactory(AbstractFactory): def product_car(self): return Mercedes_C63() def product_suv(self): return Mercedes_G63()class BMWFactory(AbstractFactory): def product_car(self): return BMW_M3() def product_suv(self): return BMW_X5()","tags":[],"categories":[{"name":"design-pattern","slug":"design-pattern","permalink":"https://handsome-feng.github.io/1night-cs/categories/design-pattern/"}]},{"title":"DBus","date":"2020-05-22T12:03:32.768Z","path":"wiki/desktop-environment/dbus/","text":"Debugging自动启动ServiceD-Bus系统提供了一种机制可以在访问某个service时，自动把应用程序运行起来。需要在/usr/share/dbus-1/services下面建立com.scorpio.test.service文件，文件的内容如下： 123[D-BUS Service]Name=com.scorpio.testExec=/path/to/scorpio/test Qt Dbus工具 qdbusviewer qdbuscpp2xml qdbuscpp2xml会解析QObject派生类的C++头文件或是源文件，生成D-Bus的内省xml文件。qdbuscpp2xml 会区分函数的输入输出，如果参数声明为const则会是输入，否则可能会被当作输出。qdbuscpp2xml使用语法如下：qdbuscpp2xml [options...] [files...]Options参数如下：-p|-s|-m：只解析脚本化的属性、信号、方法（槽函数）-P|-S|-M：解析所有的属性、信号、方法（槽函数）-a：输出所有的脚本化内容，等价于-psm-A：输出所有的内容，等价于-PSM-o filename：输出内容到filename文件解析所有的方法输出到com.scorpio.test.xml文件命令如下：qdbuscpp2xml -M test.h -o com.scorpio.test.xml 1234567891011121314151617&lt;!DOCTYPE node PUBLIC &quot;-//freedesktop//DTD D-BUS Object Introspection 1.0//EN&quot; &quot;http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd&quot;&gt;&lt;node&gt; &lt;interface name=&quot;com.scorpio.test.value&quot;&gt; &lt;method name=&quot;maxValue&quot;&gt; &lt;arg type=&quot;i&quot; direction=&quot;out&quot;/&gt; &lt;/method&gt; &lt;method name=&quot;minValue&quot;&gt; &lt;arg type=&quot;i&quot; direction=&quot;out&quot;/&gt; &lt;/method&gt; &lt;method name=&quot;value&quot;&gt; &lt;arg type=&quot;i&quot; direction=&quot;out&quot;/&gt; &lt;/method&gt; &lt;method name=&quot;setValue&quot;&gt; &lt;arg name=&quot;value&quot; type=&quot;i&quot; direction=&quot;in&quot;/&gt; &lt;/method&gt; &lt;/interface&gt;&lt;/node&gt; qdbusxml2cpp qdbusxml2cpp根据输入文件中定义的接口，生成C++实现代码。qdbusxml2cpp可以辅助自动生成继承于QDBusAbstractAdaptor和QDBusAbstractInterface两个类的实现代码，用于进程通信服务端和客户端，简化了开发者的代码设计。qdbusxml2cpp使用语法如下：qdbusxml2cpp [options...] [xml-or-xml-file] [interfaces...]Options参数如下：-a filename：输出Adaptor代码到filename-c classname：使用classname作为生成类的类名-i filename：增加#include到输出-l classname：当生成Adaptor代码时，使用classname作为父类-m：在cpp文件中包含 #include “filename.moc”语句-N：不使用名称空间-p filename：生成Proxy代码到filename文件解析com.scorpio.test.xml文件，生成Adaptor类ValueAdaptor，文件名称为valueAdaptor.h、valueAdaptor.cpp命令行如下：qdbusxml2cpp com.scorpio.test.xml -i test.h -a valueAdaptor解析com.scorpio.test.xml文件，生成Proxy类ComScorpioTestValueInterface，文件名称为testInterface.h、testInterface.cpp命令行如下：qdbusxml2cpp com.scorpio.test.xml -p testInterface dbus-daemonhttps://dbus.freedesktop.org/doc/dbus-daemon.1.html D-Bus is first a library that provides one-to-one communication between any two applications; dbus-daemon is an application that uses this library to implement a message bus daemon. Multiple programs connect to the message bus daemon and can exchange messages with one another. There are two standard message bus instances: systemwide message bus (installed on many systems as the “messagebus” init service) per-user-login-session message bus (started each time a user logs in). SIGHUP will cause the D-Bus daemon to PARTIALLY reload its configuration file and to flush its user/group information caches. Some configuration changes would require kicking all apps off the bus; so they will only take effect if you restart the daemon. Policy changes should take effect with SIGHUP. configuration fileThe standard systemwide and per-session message bus setups are configured in the files “/usr/share/dbus-1/system.conf” and “/usr/share/dbus-1/session.conf”. These files normally a system-local.conf or session-local.conf in /etc/dbus-1; you can put local overrides in those files to avoid modifying the primary configuration files. The standard system bus normally reads additional XML files from /usr/share/dbus-1/system.d. Third-party packages should install the default policies necessary for correct operation into that directory, which has been supported since dbus 1.10 (released in 2015). The standard system bus normally also reads XML files from /etc/dbus-1/system.d, which should be used by system administrators if they wish to override default policies. Third-party packages would historically install XML files into /etc/dbus-1/system.d, but this practice is now considered to be deprecated: that directory should be treated as reserved for the system administrator. The element defines a security policy to be applied to a particular set of connections to the bus. A policy is made up of and elements. Policies are normally used with the systemwide bus; they are analogous to a firewall in that they allow expected traffic and prevent unexpected traffic. In general, it is best to keep system services as small, targeted programs which run in their own process and provide a single bus name. Then, all that is needed is an rule for the “own” permission to let the process claim the bus name, and a “send_destination” rule to allow traffic from some or all uids to your service. Rules with one or more of the send_* family of attributes are checked in order when a connection attempts to send a message. The last rule that matches the message determines whether it may be sent. The well-known session bus normally allows sending any message. The well-known system bus normally allows sending any signal, selected method calls to the dbus-daemon, and exactly one reply to each previously-sent method call (either success or an error). Either of these can be overridden by configuration; on the system bus, services that will receive method calls must install configuration that allows them to do so, usually via rules of the form &lt;policy context=&quot;default&quot;&gt;&lt;allow send_destination=&quot;…&quot;/&gt;&lt;policy&gt;. DebuggingThis is trickier, because D-Bus policy typically prevents anything but signals from being viewable by dbus-monitor. But we can change that. Create a file /etc/dbus-1/system-local.conf, with these contents: 123456789&lt;!DOCTYPE busconfig PUBLIC&quot;-//freedesktop//DTD D-Bus Bus Configuration 1.0//EN&quot;&quot;http://www.freedesktop.org/standards/dbus/1.0/busconfig.dtd&quot;&gt;&lt;busconfig&gt; &lt;policy user=&quot;root&quot;&gt; &lt;allow eavesdrop=&quot;true&quot;/&gt; &lt;allow eavesdrop=&quot;true&quot; send_destination=&quot;*&quot;/&gt; &lt;/policy&gt;&lt;/busconfig&gt; Reboot your machine to pick up the configuration changes. Simply reloading the DBus server configuration is not sufficient. Now run dbus-monitor as root. You should be able to see all signals, method calls, and method replies. sudo dbus-monitor --system When done debugging, it is wise to remove the policy snippet: sudo rm /etc/dbus-1/system-local.conf Filtering all the noise If there is just too much information on the bus, pass a match rule like so: dbus-monitor “type=signal,sender=’org.gnome.TypingMonitor’,interface=’org.gnome.TypingMonitor’” Multiple rules can be specified. If a message matches any of the rules, the message will be printed. Like so: dbus-monitor “type=error” “sender=org.freedesktop.SystemToolsBackends” dbus-monitor “type=method_call” “type=method_return” “type=error” See the D-Bus documentation for more information on match rule syntax. For qt application12examples/dbus/remotecontrolledcar/controller/controller &amp;QDBUS_DEBUG=1 examples/dbus/remotecontrolledcar/car/car &amp; Dbus command tools gdbus dbus-send 1dbus-send --system --type=signal /org/freedesktop/login1 org.freedesktop.login1.PrepareForShutdown boolean:true dbus-monitor 1dbus-monitor --system interface=org.freedesktop.login1","tags":[],"categories":[{"name":"desktop-environment","slug":"desktop-environment","permalink":"https://handsome-feng.github.io/1night-cs/categories/desktop-environment/"}]},{"title":"","date":"2020-05-22T12:03:32.768Z","path":"wiki/desktop-environment/default-applications/","text":"https://wiki.archlinux.org/index.php/Default_applications","tags":[],"categories":[{"name":"desktop-environment","slug":"desktop-environment","permalink":"https://handsome-feng.github.io/1night-cs/categories/desktop-environment/"}]},{"title":"","date":"2020-05-22T12:03:32.768Z","path":"wiki/desktop-environment/lightdm/","text":"Lightdm命令行工具，它可用来锁定当前 seat, 切换会话，等等 $ dm-tool –help $ sudo apt install xserver-xephyr $ lightdm –test-mode –debug 默认打开小键盘: 安装 numlockx, 编辑 /etc/lightdm/lightdm.conf 添加以下几行: [Seat:*] greeter-setup-script=/usr/bin/numlockx on $ systemctl status lightdm.service $ systemctl help lightdm.service After enabling lightdm a symlink display-manager.service should be set in /etc/systemd/system/. You may need to use –force to override old symlinks. feng@380:~$ file /etc/systemd/system/display-manager.service /etc/systemd/system/display-manager.service: symbolic link to /lib/systemd/system/lightdm.service loginctl –help Session configuration Many display managers read available sessions from /usr/share/xsessions/ directory. It contains standard desktop entry files for each DM/WM. Starting applications without a window manager You can also launch an application without any decoration, desktop, or window management. For example to launch google-chromeAUR create a web-browser.desktop file in /usr/share/xsessions/ like this: [Desktop Entry] Encoding=UTF-8 Name=Web Browser Comment=Use a web browser as your session Exec=/usr/bin/google-chrome –auto-launch-at-startup TryExec=/usr/bin/google-chrome –auto-launch-at-startup Icon=google-chrome ~/.xinitrc or /etc/X11/xinit/xinitrc The Light Display Manager (LightDM)DescriptionLightDM is a cross-desktop display manager. A display manager is a daemon that: Runs display servers (e.g. X) where necessary. Runs greeters to allow users to pick which user account and session type to use. Allows greeters to perform authentication using PAM. Runs session processes once authentication is complete. Provides remote graphical login options. Key features of LightDM are: Cross-desktop - supports different desktop technologies. Supports different display technologies (X, Mir, Wayland …). Lightweight - low memory usage and fast performance. Guest sessions. Supports remote login (incoming - XDMCP, VNC, outgoing - XDMCP, pluggable). Comprehensive test suite. ConfigurationLightDM configuration is provided by the following files: /usr/share/lightdm/lightdm.conf.d/.conf_x000D_/etc/lightdm/lightdm.conf.d/.conf_x000D_/etc/lightdm/lightdm.conf System provided configuration should be stored in /usr/share/lightdm/lightdm.conf.d/. System administrators can override this configuration by adding files to /etc/lightdm/lightdm.conf.d/ and /etc/lightdm/lightdm.conf. Files are read in the above order and combined together to make the LightDM configuration. 配置文件书写规则http://bazaar.launchpad.net/~lightdm-team/lightdm/trunk/view/head:/data/lightdm.conf LightDM DesignWhat is a Display Manager?The responsibilities of a display manager are: Starting and managing local instances of the X server. Authenticating users. Starting and managing user sessions. Common use cases: Starting a single X server on boot and starting a session (kiosk mode). Starting a single X server instance on boot, displaying a greeter GUI (username and password), and starting the user session when connected (traditional). Supporting multiple simultaneous logins by exposing what users are logged in, and starting new X servers for each user (user switching). Running a thin-client server by allowing X servers to connect using XDMCP, and connecting greeters and sessions to those X servers. Design GoalsFast - The display manager should add no noticeable delay to startup time. Fail-safe - Failures should be handled gracefully. Secure - Resistant to malicious users. Flexible - Able to support a range of use-cases. Extensible - Able to support rarer use-cases though plugins. Simple - Configuration should be easy and the code should be simple to understand and modify. DefinitionsDisplay Manager - A daemon that manages the displays on a system. Display - A combination of an X server, greeter and a user session. User session - An application that runs on a display and allows the user to run applications. Greeter - An application to run on a display and prompt for authentication and session options. RequirementsDaemon: Able to run as as system service without user interaction Provide logging information for debugging Launch and monitor X servers Launch and monitor greeter applications for displays without a user session Launch and monitor user sessions after user is authenticated Authenticate users Provide an interface to greeter applications Provide an interface to user switchers Store a database of active displays Load sessions from /usr/share/xsessions Store session configuration in ~/.dmrc Support .dmrc not being readable before login Advertise display database to Software/ConsoleKit if available Use PAM for authentication Session environment: Set USER to the username Set HOME to users home directory Set SHELL to the users shell Set PATH to /usr/bin:/bin Set LANG to the users language Set DISPLAY to the X servers address Set environment variables from /etc/environment Static Display Module: Allow 0-N displays to be enabled at all time Support automatic/timed login User Switcher Module: Interface to switch to existing local display for a logged in user Start new static display if user not logged in XDMCP Server Module: Implement XDMCP protocol Module interface: Expose display database Greeter application/interface: User authentication Session choice Session language Session keyboard layout Logged in users ImplementationDaemon: Implemented in C+GObject Single process Greeter Interface: D-Bus GTK+ Greeter: Inter-process Relationships","tags":[],"categories":[{"name":"desktop-environment","slug":"desktop-environment","permalink":"https://handsome-feng.github.io/1night-cs/categories/desktop-environment/"}]},{"title":"","date":"2020-05-22T12:03:32.768Z","path":"wiki/desktop-environment/notification/","text":"By shell1notify-send Test &quot;hello world&quot; By codelibnotify","tags":[],"categories":[{"name":"desktop-environment","slug":"desktop-environment","permalink":"https://handsome-feng.github.io/1night-cs/categories/desktop-environment/"}]},{"title":"","date":"2020-05-22T12:03:32.768Z","path":"wiki/desktop-environment/sessionManager/","text":"Session Manager 会话管理器是什么，什么作用 KDE/GNOME ukui-session-manager优势与劣势 Multi-Seat on Linux传统的 Linux 系统使用 ConsoleKit 跟踪用户登录情况，并决定是否赋予其关机的权限。现在 ConsoleKit 已经被 systemd 的 logind 所替代。 logind 不是 pid-1 的 init 进程。它的作用和 UpStart 的 session init 类似，但功能要丰富很多，它能够管理几乎所有用户会话(session)相关的事情。logind 不仅是 ConsoleKit 的替代，它可以： 维护，跟踪会话和用户登录情况。如上所述，为了决定关机命令是否可行，系统需要了解当前用户登录情况，如果用户从 SSH 登录，不允许其执行关机命令；如果普通用户从本地登录，且该用户是系统中的唯一会话，则允许其执行关机命令；这些判断都需要 logind 维护所有的用户会话和登录情况。 Logind 也负责统计用户会话是否长时间没有操作，可以执行休眠/关机等相应操作。为用户会话的所有进程创建 CGroup。这不仅方便统计所有用户会话的相关进程，也可以实现会话级别的系统资源控制。 负责电源管理的组合键处理，比如用户按下电源键，将系统切换至睡眠状态。 多席位(multi-seat) 管理。如今的电脑，即便一台笔记本电脑，也完全可以提供多人同时使用的计算能力。多席位就是一台电脑主机管理多个外设，比如两个屏幕和两个鼠标/键盘。席位一使用屏幕 1 和键盘 1；席位二使用屏幕 2 和键盘 2，但他们都共享一台主机。用户会话可以自由在多个席位之间切换。或者当插入新的键盘，屏幕等物理外设时，自动启动 gdm 用户登录界面等。所有这些都是多席位管理的内容。ConsoleKit 始终没有实现这个功能，systemd 的 logind 能够支持多席位。 好的一点是，这非常有助于标准化 Linux 的管理！从前，不同的 Linux 发行版各行其事，使用不同方法管理系统，从来也不会互相妥协。比如如何将系统进入休眠状态，不同的系统有不同的解决方案，即便是同一个 Linux 系统，也存在不同的方法，比如一个有趣的讨论：如何让 ubuntu 系统休眠，可以使用底层的/sys/power/state 接口，也可以使用诸如 pm-utility 等高层接口。存在这么多种不同的方法做一件事情对像我这样的普通用户而言可不是件有趣的事情。systemd 提供统一的电源管理命令接口，这件事情的意义就类似全世界的人都说统一的语言，我们再也不需要学习外语了，多么美好！ X Session Management Protocol The purpose of the X Session Management Protocol (XSMP) is to provide a uniform mechanism for users to save and restore their sessions. A session is a group of clients, each of which has a particular state. Mate Session Managerrequire_dbus_session gsm_util_export_activation_environment gsm_util_export_user_environment check_gl XDG_CURRENT_DESKTOP=MATE DISPLAY=gdk_display_get_name MATE_DESKTOP_SESSION_ID=this-is-deprecated initialize_gsettings accessibility: GTK_MODULES=gail:atk-bridge gsm_store_new gsm_xsmp_server_new acquire_name msm_gnome_start() //gnome compat mode: keyring, smproxy set_overlay_scroll gsm_manager_new mdm_signal_hander_new load_standard_apps(初始化为autostart_app, add进client_store) ​ maybe_load_saved_session_apps ​ gsm_manager_add_autostart_apps_from_dir ​ append_default_app: ukui-settings-daemon ​ append_required_apps: dock, filemanager, panel, windowmanager ​ append_accessibility_apps: 123456789101112131415161718192021222324252627typedef enum &#123; /* gsm&apos;s own startup/initialization phase */ GSM_MANAGER_PHASE_STARTUP = 0, /* xrandr setup, mate-settings-daemon, etc */ GSM_MANAGER_PHASE_INITIALIZATION, /* window/compositing managers */ GSM_MANAGER_PHASE_WINDOW_MANAGER, /* apps that will create _NET_WM_WINDOW_TYPE_PANEL windows */ GSM_MANAGER_PHASE_PANEL, /* apps that will create _NET_WM_WINDOW_TYPE_DESKTOP windows */ GSM_MANAGER_PHASE_DESKTOP, /* everything else */ GSM_MANAGER_PHASE_APPLICATION, /* done launching */ GSM_MANAGER_PHASE_RUNNING, /* shutting down */ GSM_MANAGER_PHASE_QUERY_END_SESSION, GSM_MANAGER_PHASE_END_SESSION, GSM_MANAGER_PHASE_EXIT&#125; GsmManagerPhase; libegghttps://gitlab.gnome.org/GNOME/libegg/raw/master/libegg/smclient/README KDE ksmserver sanity_check(he(合理性检验) HOME, ICEAUTHORITY, KDETMP/ice-unix(socket directory where X-windows session information is saved) SESSION_MANAGER= checkComposite() QT_QPA_PLATFORM=xcb when launchpad ksmserver self fcntl(ConnectionNumber(QX11Info::display()), F_SETFD, 1); check_library_exists(ICE _IceTransNoListen “” HAVE__ICETRANSNOLISTEN) setupShortcuts inhibit org.freedesktop.login1.Manager.Inhibit org.gnome.SessionManager.Inhibitor Power Manager systemd-inhibit Ref: https://www.freedesktop.org/wiki/Software/systemd/inhibit/","tags":[],"categories":[{"name":"desktop-environment","slug":"desktop-environment","permalink":"https://handsome-feng.github.io/1night-cs/categories/desktop-environment/"}]},{"title":"","date":"2020-05-22T12:03:32.768Z","path":"wiki/desktop-environment/占用资源分析/","text":"冷启动后，打开终端，查看内存情况： free -mh 查看各个进程内存使用情况： ps aux –sort -rss","tags":[],"categories":[{"name":"desktop-environment","slug":"desktop-environment","permalink":"https://handsome-feng.github.io/1night-cs/categories/desktop-environment/"}]},{"title":"keyboard","date":"2020-05-22T12:03:32.768Z","path":"wiki/device/keyboard/","text":"12345678910111213141516171819202122232425262728/* - date: 2016.11.24- build: gcc fake_keyboard.cpp `pkg-config --cflags --libs x11 gtk+-3.0 xtst`- */#include &lt;gdk/gdkx.h&gt;#include &lt;gtk/gtk.h&gt;#include &lt;X11/extensions/XTest.h&gt;#include &lt;iostream&gt;using namespace std;int main(int argc, char** argv)&#123;gtk_init(&amp;argc, &amp;argv);KeySym key = XK_Super_L;GdkDisplay *gdk_display = gdk_display_get_default();Display *display = gdk_x11_display_get_xdisplay(gdk_display);int c;int x = 0;while((c=cin.get())!=EOF) &#123; XTestFakeMotionEvent(display, 0, x++, 100, 0); XSync(display, False);&#125;gtk_main();return 0;&#125;","tags":[],"categories":[{"name":"device","slug":"device","permalink":"https://handsome-feng.github.io/1night-cs/categories/device/"}]},{"title":"","date":"2020-05-22T12:03:32.768Z","path":"wiki/device/显卡/","text":"查看显卡 lspci -k | grep -A 2 -i “VGA” ls /dev/dri/ 查看显卡驱动 sudo lshw -c display 安装显卡驱动 软件与更新 -&gt; 附加驱动 sudo ubuntu-drivers devices sudo ubuntu-drivers autoinstall or sudo apt install nvidia-driver-[num] 查看在使用哪个显卡 prime-select query 切换显卡 sudo prime-select intel sudo prime-select nvidia 或者 sudo apt install nvidia-settings 禁止N卡： sudo vim /etc/modprobe.d/blacklist.conf 添加 blacklist nouveau 显卡消失： Step 1 : Remove all NVIDIA related software you installed. Highlight the Ubuntu menu entry and press the E key.Add nouveau.modeset=0 to the end of the linux line.Press the F10 key to boot into the Ubuntu system. When the login screen appears press Ctrl+Alt+F1.Enter your user name and password … then execute : 12sudo apt-get purge nvidia* bumblebeesudo reboot Step 2 : Reinstall the NVIDIA drivers and Optimus support. Highlight the Ubuntu menu entry and press the E key.Add nouveau.modeset=0 to the end of the linux line.Press the F10 key to boot into the Ubuntu system. When the login screen appears press Ctrl+Alt+F1.Enter your user name and password … then execute : 123sudo apt-get updatesudo apt-get install nvidia-352 nvidia-primesudo reboot 在nvidia-settings里切换到inter显卡，重启，再切换到n卡，再重启，就回来了","tags":[],"categories":[{"name":"device","slug":"device","permalink":"https://handsome-feng.github.io/1night-cs/categories/device/"}]},{"title":"touchpad","date":"2020-05-22T12:03:32.768Z","path":"wiki/device/触摸板/","text":"查看输入设备： xinput –list 安装驱动： sudo apt install xserver-xrog-input-synaptics （xserver-xorg-input-all)","tags":[],"categories":[{"name":"device","slug":"device","permalink":"https://handsome-feng.github.io/1night-cs/categories/device/"}]},{"title":"","date":"2020-05-22T12:03:32.768Z","path":"wiki/language/cpp_styleguide/","text":"Cpp style guide头文件前置声明尽可能避免使用前置声明。 缺点： 前置声明隐藏了依赖关系，头文件改动时，用户的代码会跳过必要的重新编译过程。 前置声明可能会被库的后续更改所破坏。前置声明函数或模板有时会妨碍头文件开发者变动其 API. 例如扩大形参类型，加个自带默认参数的模板形参等等。 前置声明来自命名空间 std:: 的 symbol 时，其行为未定义。 很难判断什么时候该用前置声明，什么时候该用 #include 。极端情况下，用前置声明代替 includes 甚至都会暗暗地改变代码的含义： 12345678910&gt; &gt; // b.h:&gt; &gt; struct B &#123;&#125;;&gt; &gt; struct D : B &#123;&#125;;&gt; &gt; &gt; &gt; // good_user.cc:&gt; &gt; #include &quot;b.h&quot;&gt; &gt; void f(B*);&gt; &gt; void f(void*);&gt; &gt; void test(D* x) &#123; f(x); &#125; // calls f(B*)&gt; &gt; 如果 #include 被 B 和 D 的前置声明替代， test() 就会调用 f(void*) . 前置声明了不少来自头文件的 symbol 时，就会比单单一行的 include 冗长。 仅仅为了能前置声明而重构代码（比如用指针成员代替对象成员）会使代码变得更慢更复杂. 內联函数一个较为合理的经验准则是, 不要内联超过 10 行的函数. 谨慎对待析构函数, 析构函数往往比其表面看起来要更长, 因为有隐含的成员和基类析构函数被调用! 另一个实用的经验准则: 内联那些包含循环或 switch 语句的函数常常是得不偿失 (除非在大多数情况下, 这些循环或 switch 语句从不被执行). 有些函数即使声明为内联的也不一定会被编译器内联, 这点很重要; 比如虚函数和递归函数就不会被正常内联. 通常, 递归函数不应该声明成内联函数.（YuleFox 注: 递归调用堆栈的展开并不像循环那么简单, 比如递归层数在编译时可能是未知的, 大多数编译器都不支持内联递归函数). 虚函数内联的主要原因则是想把它的函数体放在类定义内, 为了图个方便, 抑或是当作文档描述其行为, 比如精短的存取函数. #include的路径和顺序次序如下： dir2/foo2.h (优先位置, 详情如下) C 系统文件 C++ 系统文件 其他库的 .h 文件 本项目内 .h 文件 作用域命名空间內联命名空间主要用来保持跨版本的ABI兼容性 非成员函数、静态成员函数和全局函数使用静态成员函数或命名空间内的非成员函数, 尽量不要用裸的全局函数. 将一系列函数直接置于命名空间中，不要用类的静态方法模拟出命名空间的效果，类的静态方法应当和类的实例或静态数据紧密相关. 局部变量将函数变量尽可能置于最小作用域内, 并在变量声明时进行初始化. C++ 允许在函数的任何位置声明变量. 我们提倡在尽可能小的作用域中声明变量, 离第一次使用越近越好. 这使得代码浏览者更容易定位变量声明的位置, 了解变量的类型和初始值. 特别是，应使用初始化的方式替代声明再赋值, 比如: 12345678&gt; int i;&gt; i = f(); // 坏——初始化和声明分离&gt; int j = g(); // 好——初始化时声明&gt; vector&lt;int&gt; v;&gt; v.push_back(1); // 用花括号初始化更好&gt; v.push_back(2);&gt; vector&lt;int&gt; v = &#123;1, 2&#125;; // 好——v 一开始就初始化&gt; 属于 if, while 和 for 语句的变量应当在这些语句中正常地声明，这样子这些变量的作用域就被限制在这些语句中了，举例而言: 12&gt; while (const char* p = strchr(str, &apos;/&apos;)) str = p + 1;&gt; Warning 有一个例外, 如果变量是一个对象, 每次进入作用域都要调用其构造函数, 每次退出作用域都要调用其析构函数. 这会导致效率降低. 12345// 低效的实现for (int i = 0; i &lt; 1000000; ++i) &#123; Foo f; // 构造函数和析构函数分别调用 1000000 次! f.DoSomething(i);&#125; 在循环作用域外面声明这类变量要高效的多: 1234Foo f; // 构造函数和析构函数只调用 1 次for (int i = 0; i &lt; 1000000; ++i) &#123; f.DoSomething(i);&#125; 静态和全局变量禁止定义静态储存周期非POD变量，禁止使用含有副作用的函数初始化POD全局变量，因为多编译单元中的静态变量执行时的构造和析构顺序是未明确的，这将导致代码的不可移植。 同一个编译单元内是明确的，静态初始化优先于动态初始化，初始化顺序按照声明顺序进行，销毁则逆序。不同的编译单元之间初始化和销毁顺序属于未明确行为 (unspecified behaviour)。 类构造函数优点 无需考虑类是否被初始化. 经过构造函数完全初始化后的对象可以为 const 类型, 也能更方便地被标准容器或算法使用. 缺点 如果在构造函数内调用了自身的虚函数, 这类调用是不会重定向到子类的虚函数实现. 即使当前没有子类化实现, 将来仍是隐患. 在没有使程序崩溃 (因为并不是一个始终合适的方法) 或者使用异常 (因为已经被 禁用 了) 等方法的条件下, 构造函数很难上报错误 如果执行失败, 会得到一个初始化失败的对象, 这个对象有可能进入不正常的状态, 必须使用 bool IsValid() 或类似这样的机制才能检查出来, 然而这是一个十分容易被疏忽的方法. 构造函数的地址是无法被取得的, 因此, 举例来说, 由构造函数完成的工作是无法以简单的方式交给其他线程的. 结论 构造函数不允许调用虚函数. 如果代码允许, 直接终止程序是一个合适的处理错误的方式. 否则, 考虑用 Init() 方法或工厂函数. 构造函数不得调用虚函数, 或尝试报告一个非致命错误. 如果对象需要进行有意义的 (non-trivial) 初始化, 考虑使用明确的 Init() 方法或使用工厂模式. Avoid Init() methods on objects with no other states that affect which public methods may be called (此类形式的半构造对象有时无法正确工作). 隐式类型转换在类型定义中, 类型转换运算符和单参数构造函数都应当用 explicit 进行标记. 一个例外是, 拷贝和移动构造函数不应当被标记为 explicit, 因为它们并不执行类型转换. 可拷贝类型和可移动类型如果你的类型需要, 就让它们支持拷贝 / 移动. 否则, 就把隐式产生的拷贝和移动函数禁用. 为避免拷贝构造函数, 赋值操作的滥用和编译器自动生成, 可将其声明为 private 且无需实现; 继承所有继承必须是 public 的. 如果你想使用私有继承, 你应该替换成把基类的实例作为成员对象的方式. 不要过度使用实现继承. 组合常常更合适一些. 尽量做到只在 “是一个” (“is-a”, YuleFox 注: 其他 “has-a” 情况下请使用组合) 的情况下使用继承: 如果 Bar 的确 “是一种” Foo, Bar 才能继承 Foo. 必要的话, 析构函数声明为 virtual. 如果你的类有虚函数, 则析构函数也应该为虚函数. 对于可能被子类访问的成员函数, 不要过度使用 protected 关键字. 注意, 数据成员都必须是 私有的. 对于重载的虚函数或虚析构函数, 使用 override, 或 (较不常用的) final 关键字显式地进行标记. 较早 (早于 C++11) 的代码可能会使用 virtual 关键字作为不得已的选项. 因此, 在声明重载时, 请使用 override, final 或 virtual 的其中之一进行标记. 标记为 override 或 final 的析构函数如果不是对基类虚函数的重载的话, 编译会报错, 这有助于捕获常见的错误. 这些标记起到了文档的作用, 因为如果省略这些关键字, 代码阅读者不得不检查所有父类, 以判断该函数是否是虚函数. 多重继承只有当所有父类除第一个外都是 纯接口类 时, 才允许使用多重继承. 为确保它们是纯接口, 这些类必须以 Interface 为后缀. 运算符重载只有在意义明显, 不会出现奇怪的行为并且与对应的内建运算符的行为一致时才定义重载运算符. 例如, | 要作为位或或逻辑或来使用, 而不是作为 shell 中的管道. 只有对用户自己定义的类型重载运算符. 更准确地说, 将它们和它们所操作的类型定义在同一个头文件中, .cc 中和命名空间中. 这样做无论类型在哪里都能够使用定义的运算符, 并且最大程度上避免了多重定义的风险. 如果可能的话, 请避免将运算符定义为模板, 因为此时它们必须对任何模板参数都能够作用. 如果你定义了一个运算符, 请将其相关且有意义的运算符都进行定义, 并且保证这些定义的语义是一致的. 例如, 如果你重载了 &lt;, 那么请将所有的比较运算符都进行重载, 并且保证对于同一组参数, &lt; 和 &gt; 不会同时返回 true. 建议不要将不进行修改的二元运算符定义为成员函数. 如果一个二元运算符被定义为类成员, 这时隐式转换会作用域右侧的参数却不会作用于左侧. 这时会出现 a &lt; b 能够通过编译而 b &lt; a 不能的情况, 这是很让人迷惑的. 不要为了避免重载操作符而走极端. 比如说, 应当定义 ==, =, 和 &lt;&lt; 而不是 Equals(), CopyFrom() 和 PrintTo(). 反过来说, 不要只是为了满足函数库需要而去定义运算符重载. 比如说, 如果你的类型没有自然顺序, 而你要将它们存入 std::set 中, 最好还是定义一个自定义的比较运算符而不是重载 &lt;. 不要重载 &amp;&amp;, ||, , 或一元运算符 &amp;. 不要重载 operator&quot;&quot;, 也就是说, 不要引入用户定义字面量. 类型转换运算符在 隐式类型转换 一节有提及. = 运算符在 可拷贝类型和可移动类型 一节有提及. 运算符 &lt;&lt; 在 流 一节有提及. 同时请参见 函数重载 一节, 其中提到的的规则对运算符重载同样适用. 存取控制将所有数据成员声明为private, 除非是static const类型成员. 声明顺序类定义一般应以 public: 开始, 后跟 protected:, 最后是 private:. 省略空部分. 在各个部分中, 建议将类似的声明放在一起, 并且建议以如下的顺序: 类型 (包括 typedef, using 和嵌套的结构体与类), 常量, 工厂函数, 构造函数, 赋值运算符, 析构函数, 其它函数, 数据成员. 不要将大段的函数定义内联在类定义中. 通常，只有那些普通的, 或性能关键且短小的函数可以内联在类定义中. 函数参数类型函数的参数顺序为: 输入参数在先, 后跟输出参数. 引用参数函数参数列表中, 所有引用参数都必须是 const: 1void Foo(const string &amp;in, string *out); 事实上这在 Google Code 是一个硬性约定: 输入参数是值参或 const 引用, 输出参数为指针. 输入参数可以是 const 指针, 但决不能是非 const 的引用参数, 除非特殊要求, 比如 swap(). 有时候, 在输入形参中用 const T* 指针比 const T&amp; 更明智. 比如: 可能会传递空指针. 函数要把指针或对地址的引用赋值给输入形参. 总而言之, 大多时候输入形参往往是 const T&amp;. 若用 const T* 则说明输入另有处理. 所以若要使用 const T*, 则应给出相应的理由, 否则会使得读者感到迷惑. 函数重载缺省参数对于虚函数, 不允许使用缺省参数, 因为在虚函数中缺省参数不一定能正常工作. 如果在每个调用点缺省参数的值都有可能不同, 在这种情况下缺省函数也不允许使用. (例如, 不要写像 void f(int n = counter++); 这样的代码.) 在其他情况下, 如果缺省参数对可读性的提升远远超过了以上提及的缺点的话, 可以使用缺省参数. 如果仍有疑惑, 就使用函数重载. 其他C++特性右值引用变长数组和alloca()优点: 变长数组具有浑然天成的语法. 变长数组和 alloca() 也都很高效. 缺点: 变长数组和 alloca() 不是标准 C++ 的组成部分. 更重要的是, 它们根据数据大小动态分配堆栈内存, 会引起难以发现的内存越界 bugs: “在我的机器上运行的好好的, 发布后却莫名其妙的挂掉了”. 结论: 改用更安全的分配器（allocator），就像 std::vector 或 std::unique_ptr&lt;T[]&gt;. 类型转换定义: C++ 采用了有别于 C 的类型转换机制, 对转换操作进行归类. 优点: C 语言的类型转换问题在于模棱两可的操作; 有时是在做强制转换 (如 (int)3.5), 有时是在做类型转换 (如 (int)&quot;hello&quot;). 另外, C++ 的类型转换在查找时更醒目. 缺点: 恶心的语法. 结论: 不要使用 C 风格类型转换. 而应该使用 C++ 风格. 用 static_cast 替代 C 风格的值转换, 或某个类指针需要明确的向上转换为父类指针时. 用 const_cast 去掉 const 限定符. 用 reinterpret_cast 指针类型和整型或其它指针之间进行不安全的相互转换. 仅在你对所做一切了然于心时使用. 至于 dynamic_cast 参见 运行时类型识别. 前置自增和自减不考虑返回值的话, 前置自增 (++i) 通常要比后置自增 (i++) 效率更高. 因为后置自增 (或自减) 需要对表达式的值 i 进行一次拷贝. 如果 i 是迭代器或其他非数值类型, 拷贝的代价是比较大的. 对简单数值 (非对象), 两种都无所谓. 对迭代器和模板类型, 使用前置自增 (自减). 预处理宏下面给出的用法模式可以避免使用宏带来的问题; 如果你要宏, 尽可能遵守: 不要在 .h 文件中定义宏. 在马上要使用时才进行 #define, 使用后要立即 #undef. 不要只是对已经存在的宏使用#undef，选择一个不会冲突的名称； 不要试图使用展开后会导致 C++ 构造不稳定的宏, 不然也至少要附上文档说明其行为. 不要用 ## 处理函数，类和变量的名字。 0, nullptr, NULL整数用 0, 实数用 0.0, 指针用 nullptr 或 NULL, 字符 (串) 用 &#39;\\0&#39;. 整数用 0, 实数用 0.0, 这一点是毫无争议的. 对于指针 (地址值), 到底是用 0, NULL 还是 nullptr. C++11 项目用 nullptr; C++03 项目则用 NULL, 毕竟它看起来像指针。实际上，一些 C++ 编译器对 NULL 的定义比较特殊，可以输出有用的警告，特别是 sizeof(NULL) 就和 sizeof(0) 不一样。 字符 (串) 用 &#39;\\0&#39;, 不仅类型正确而且可读性好. auto auto 和 C++11 列表初始化的合体令人摸不着头脑： 123&gt; auto x(3); // 圆括号。&gt; auto y&#123;3&#125;; // 大括号。&gt; 它们不是同一回事——x 是 int, y 则是 std::initializer_list&lt;int&gt;. 其它一般不可见的代理类型（acgtyrant 注：normally-invisible proxy types, 它涉及到 C++ 鲜为人知的坑：Why is vector not a STL container?）也有大同小异的陷阱。 如果在接口里用 auto, 比如声明头文件里的一个常量，那么只要仅仅因为程序员一时修改其值而导致类型变化的话——API 要翻天覆地了。 结论： auto 只能用在局部变量里用。别用在文件作用域变量，命名空间作用域变量和类数据成员里。永远别列表初始化 auto 变量。 auto 还可以和 C++11 特性「尾置返回类型（trailing return type）」一起用，不过后者只能用在 lambda 表达式里。 列表初始化你可以用列表初始化。 早在 C++03 里，聚合类型（aggregate types）就已经可以被列表初始化了，比如数组和不自带构造函数的结构体： 123&gt; struct Point &#123; int x; int y; &#125;;&gt; Point p = &#123;1, 2&#125;;&gt; C++11 中，该特性得到进一步的推广，任何对象类型都可以被列表初始化。示范如下： 1234567891011121314151617181920212223&gt; // Vector 接收了一个初始化列表。&gt; vector&lt;string&gt; v&#123;\"foo\", \"bar\"&#125;;&gt; &gt; // 不考虑细节上的微妙差别，大致上相同。&gt; // 您可以任选其一。&gt; vector&lt;string&gt; v = &#123;\"foo\", \"bar\"&#125;;&gt; &gt; // 可以配合 new 一起用。&gt; auto p = new vector&lt;string&gt;&#123;\"foo\", \"bar\"&#125;;&gt; &gt; // map 接收了一些 pair, 列表初始化大显神威。&gt; map&lt;int, string&gt; m = &#123;&#123;1, \"one\"&#125;, &#123;2, \"2\"&#125;&#125;;&gt; &gt; // 初始化列表也可以用在返回类型上的隐式转换。&gt; vector&lt;int&gt; test_function() &#123; return &#123;1, 2, 3&#125;; &#125;&gt; &gt; // 初始化列表可迭代。&gt; for (int i : &#123;-1, -2, -3&#125;) &#123;&#125;&gt; &gt; // 在函数调用里用列表初始化。&gt; void TestFunction2(vector&lt;int&gt; v) &#123;&#125;&gt; TestFunction2(&#123;1, 2, 3&#125;);&gt; 用户自定义类型也可以定义接收 std::initializer_list&lt;T&gt; 的构造函数和赋值运算符，以自动列表初始化： 1234567891011121314&gt; class MyType &#123;&gt; public:&gt; // std::initializer_list 专门接收 init 列表。&gt; // 得以值传递。&gt; MyType(std::initializer_list&lt;int&gt; init_list) &#123;&gt; for (int i : init_list) append(i);&gt; &#125;&gt; MyType&amp; operator=(std::initializer_list&lt;int&gt; init_list) &#123;&gt; clear();&gt; for (int i : init_list) append(i);&gt; &#125;&gt; &#125;;&gt; MyType m&#123;2, 3, 5, 7&#125;;&gt; 最后，列表初始化也适用于常规数据类型的构造，哪怕没有接收 std::initializer_list&lt;T&gt; 的构造函数。 123456789101112&gt; double d&#123;1.23&#125;;&gt; // MyOtherType 没有 std::initializer_list 构造函数，&gt; // 直接上接收常规类型的构造函数。&gt; class MyOtherType &#123;&gt; public:&gt; explicit MyOtherType(string);&gt; MyOtherType(int, string);&gt; &#125;;&gt; MyOtherType m = &#123;1, \"b\"&#125;;&gt; // 不过如果构造函数是显式的（explict），您就不能用 `= &#123;&#125;` 了。&gt; MyOtherType m&#123;\"b\"&#125;;&gt; 千万别直接列表初始化 auto 变量，看下一句，估计没人看得懂： Warning 123&gt; auto d = &#123;1.23&#125;; // d 即是 std::initializer_list&lt;double&gt;&gt; auto d = double&#123;1.23&#125;; // 善哉 -- d 即为 double, 并非 std::initializer_list.&gt; Lambda 按 format 小用 lambda 表达式怡情。 禁用默认捕获，捕获都要显式写出来。打比方，比起 [=](int x) {return x + n;}, 您该写成 [n](int x) {return x + n;} 才对，这样读者也好一眼看出 n 是被捕获的值。 匿名函数始终要简短，如果函数体超过了五行，那么还不如起名（acgtyrant 注：即把 lambda 表达式赋值给对象），或改用函数。 如果可读性更好，就显式写出 lambd 的尾置返回类型，就像auto. 命名约定文件命名文件名要全部小写, 可以包含下划线 (_) 或连字符 (-), 依照项目的约定. 如果没有约定, 那么 “_” 更好. 不要使用已经存在于 /usr/include 下的文件名 内联函数必须放在 .h 文件中. 如果内联函数比较短, 就直接放在 .h 中. 类型命名总述 类型名称的每个单词首字母均大写, 不包含下划线: MyExcitingClass, MyExcitingEnum. 说明 所有类型命名 —— 类, 结构体, 类型定义 (typedef), 枚举, 类型模板参数 —— 均使用相同约定, 即以大写字母开始, 每个单词首字母均大写, 不包含下划线. 例如: 12345678910111213// 类和结构体class UrlTable &#123; ...class UrlTableTester &#123; ...struct UrlTableProperties &#123; ...// 类型定义typedef hash_map&lt;UrlTableProperties *, string&gt; PropertiesMap;// using 别名using PropertiesMap = hash_map&lt;UrlTableProperties *, string&gt;;// 枚举enum UrlTableErrors &#123; ... 变量命名普通变量命名1234string table_name; // 好 - 用下划线.string tablename; // 好 - 全小写.string tableName; // 差 - 混合大小写 类数据成员不管是静态的还是非静态的, 类数据成员都可以和普通变量一样, 但要接下划线. 1234567class TableInfo &#123; ... private: string table_name_; // 好 - 后加下划线. string tablename_; // 好. static Pool&lt;TableInfo&gt;* pool_; // 好.&#125;; 不管是静态的还是非静态的, 结构体数据成员都可以和普通变量一样, 不用像类那样接下划线: 12345struct UrlTableProperties &#123; string name; int num_entries; static Pool&lt;UrlTableProperties&gt;* pool;&#125;; 常量命名声明为 constexpr 或 const 的变量, 或在程序运行期间其值始终保持不变的, 命名时以 “k” 开头, 大小写混合. 例如: 1const int kDaysInAWeek = 7; 说明 所有具有静态存储类型的变量 (例如静态变量或全局变量, 参见 存储类型) 都应当以此方式命名. 对于其他存储类型的变量, 如自动变量等, 这条规则是可选的. 如果不采用这条规则, 就按照一般的变量命名规则. 函数命名总述 常规函数使用大小写混合, 取值和设值函数则要求与变量名匹配: MyExcitingFunction(), MyExcitingMethod(), my_exciting_member_variable(), set_my_exciting_member_variable(). 说明 一般来说, 函数名的每个单词首字母大写 (即 “驼峰变量名” 或 “帕斯卡变量名”), 没有下划线. 对于首字母缩写的单词, 更倾向于将它们视作一个单词进行首字母大写 (例如, 写作 StartRpc() 而非 StartRPC()). 123AddTableEntry()DeleteUrl()OpenFileOrDie() (同样的命名规则同时适用于类作用域与命名空间作用域的常量, 因为它们是作为 API 的一部分暴露对外的, 因此应当让它们看起来像是一个函数, 因为在这时, 它们实际上是一个对象而非函数的这一事实对外不过是一个无关紧要的实现细节.) 取值和设值函数的命名与变量一致. 一般来说它们的名称与实际的成员变量对应, 但并不强制要求. 例如 int count() 与 void set_count(int count). 命名空间命名总述 命名空间以小写字母命名. 最高级命名空间的名字取决于项目名称. 要注意避免嵌套命名空间的名字之间和常见的顶级命名空间的名字之间发生冲突. 顶级命名空间的名称应当是项目名或者是该命名空间中的代码所属的团队的名字. 命名空间中的代码, 应当存放于和命名空间的名字匹配的文件夹或其子文件夹中. 注意 不使用缩写作为名称 的规则同样适用于命名空间. 命名空间中的代码极少需要涉及命名空间的名称, 因此没有必要在命名空间中使用缩写. 要避免嵌套的命名空间与常见的顶级命名空间发生名称冲突. 由于名称查找规则的存在, 命名空间之间的冲突完全有可能导致编译失败. 尤其是, 不要创建嵌套的 std 命名空间. 建议使用更独特的项目标识符 (websearch::index, websearch::index_util) 而非常见的极易发生冲突的名称 (比如 websearch::util). 对于 internal 命名空间, 要当心加入到同一 internal 命名空间的代码之间发生冲突 (由于内部维护人员通常来自同一团队, 因此常有可能导致冲突). 在这种情况下, 请使用文件名以使得内部名称独一无二 (例如对于 frobber.h, 使用 websearch::index::frobber_internal). 枚举命名总述 枚举的命名应当和 常量 或 宏 一致: kEnumName 或是 ENUM_NAME. 说明 单独的枚举值应该优先采用 常量 的命名方式. 但 宏 方式的命名也可以接受. 枚举名 UrlTableErrors(以及 AlternateUrlTableErrors) 是类型, 所以要用大小写混合的方式. 12345678910enum UrlTableErrors &#123; kOK = 0, kErrorOutOfMemory, kErrorMalformedInput,&#125;;enum AlternateUrlTableErrors &#123; OK = 0, OUT_OF_MEMORY = 1, MALFORMED_INPUT = 2,&#125;; 2009 年 1 月之前, 我们一直建议采用 宏 的方式命名枚举值. 由于枚举值和宏之间的命名冲突, 直接导致了很多问题. 由此, 这里改为优先选择常量风格的命名方式. 新代码应该尽可能优先使用常量风格. 但是老代码没必要切换到常量风格, 除非宏风格确实会产生编译期问题. 宏命名总述 你并不打算 使用宏, 对吧? 如果你一定要用, 像这样命名: MY_MACRO_THAT_SCARES_SMALL_CHILDREN. 说明 参考 预处理宏; 通常 不应该 使用宏. 如果不得不用, 其命名像枚举命名一样全部大写, 使用下划线: 12#define ROUND(x) ...#define PI_ROUNDED 3.0 命名规则的特例总述 如果你命名的实体与已有 C/C++ 实体相似, 可参考现有命名策略. bigopen(): 函数名, 参照 open() 的形式 1uint`: `typedef bigpos: struct 或 class, 参照 pos 的形式 sparse_hash_map: STL 型实体; 参照 STL 命名约定 1LONGLONG_MAX`: 常量, 如同 `INT_MAX 格式函数声明与定义总述 返回类型和函数名在同一行, 参数也尽量放在同一行, 如果放不下就对形参分行, 分行方式与 函数调用 一致. 说明 函数看上去像这样: 1234ReturnType ClassName::FunctionName(Type par_name1, Type par_name2) &#123; DoSomething(); ...&#125; 注意以下几点: 使用好的参数名. 只有在参数未被使用或者其用途非常明显时, 才能省略参数名. 如果返回类型和函数名在一行放不下, 分行. 如果返回类型与函数声明或定义分行了, 不要缩进. 左圆括号总是和函数名在同一行. 函数名和左圆括号间永远没有空格. 圆括号与参数间没有空格. 左大括号总在最后一个参数同一行的末尾处, 不另起新行. 右大括号总是单独位于函数最后一行, 或者与左大括号同一行. 右圆括号和左大括号间总是有一个空格. 所有形参应尽可能对齐. 缺省缩进为 4 个空格. 换行后的参数保持 4 个空格的缩进. 未被使用的参数如果其用途不明显的话, 在函数定义处将参数名注释起来: 12345678910111213class Shape &#123; public: virtual void Rotate(double radians) = 0;&#125;;class Circle : public Shape &#123; public: void Rotate(double radians) override;&#125;;void Circle::Rotate(double /*radians*/) &#123;&#125;// 差 - 如果将来有人要实现, 很难猜出变量的作用.void Circle::Rotate(double) &#123;&#125; 属性, 和展开为属性的宏, 写在函数声明或定义的最前面, 即返回类型之前: 1MUST_USE_RESULT bool IsOK(); 条件语句1234567if (condition) &#123; // 圆括号里没有空格. ... // 2 空格缩进.&#125; else if (...) &#123; // else 与 if 的右括号同一行. ...&#125; else &#123; ...&#125; 循环和开关选择12345678910111213switch (var) &#123; case 0: &#123; // 2 空格缩进 ... // 4 空格缩进 break; &#125; case 1: &#123; ... break; &#125; default: &#123; assert(false); &#125;&#125;","tags":[],"categories":[{"name":"language","slug":"language","permalink":"https://handsome-feng.github.io/1night-cs/categories/language/"}]},{"title":"","date":"2020-05-22T12:03:32.768Z","path":"wiki/language/python/","text":"熟悉Python语言，掌握函数式和面向对象编程，能够编写模块化、可重用、易维护的代码； 掌握Nginx + Django Web开发； Debug print assert logging pdb python -m pdb hello.py pdb.set_trace() 和静态语言不同，Python允许对实例变量绑定任何数据，也就是说，对于两个实例变量，虽然它们都是同一个类的不同实例，但拥有的变量名称都可能不同 有些时候，你会看到以一个下划线开头的实例变量名，比如_name，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。 双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问name是因为Python解释器对外把name变量改成了_Student__name，所以，仍然可以通过_Student__name来访问__name变量： 这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。 实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性 GIL 线程全局锁多路复用select: 1. 连接数受限; 2. fd集合从用户态拷贝到内核态; 3. 遍历所有fd，查找速度慢 poll: 改善1 epoll: 闭包协程windows下将python文件转为可执行文件：pip install pyinstaller pyinstaller -F foo.py 鼠键模拟: PyUserInput浏览器调试： selenium浏览器UA: fake_useragent","tags":[],"categories":[{"name":"language","slug":"language","permalink":"https://handsome-feng.github.io/1night-cs/categories/language/"}]},{"title":"Shell","date":"2020-05-22T12:03:32.768Z","path":"wiki/language/shell/","text":"12345678$# 是传给脚本的参数个数$0 是脚本本身的名字$1 是传递给该shell脚本的第一个参数$2 是传递给该shell脚本的第二个参数$@ 是传给脚本的所有参数的列表$* 是以一个单字符串显示所有向脚本传递的参数，与位置变量不同，参数可超过9个$$ 是脚本运行的当前进程ID号$? 是显示最后命令的退出状态，0表示没有错误，其他表示有错误 调试bash -n scriptnamebash -v scriptnamebash -x scriptname 批量改名: 1for k in $(ls); do mv $&#123;k&#125; `echo $&#123;k&#125; | sed 's/aaa//g'`; done 批量替换： sed -i “s/oldstring/newstring/g” grep oldstring -rl yourdir 连接字符串： echo “0”${k} 删除每行开头的所有空格 sed ‘s/^[ ]//g’ test find . -name &quot;\\*.c&quot; | xargs grep -H &quot;hello&quot; watch -d -n 1 tree -L 1 /usr/share/applications &gt;/dev/null 2&gt;&amp;1文件描述符： 类型 文件描述符 默认情况 对应文件句柄位置 标准输入（standard input） 0 从键盘获得输入 /proc/slef/fd/0 标准输出（standard output） 1 输出到屏幕（即控制台） /proc/slef/fd/1 错误输出（error output） 2 输出到屏幕（即控制台） /proc/slef/fd/2 输出重定向： 命令 介绍 command &gt;filename 把标准输出重定向到新文件中 command 1&gt;filename 同上 command &gt;&gt;filename 把标准输出追加到文件中 command 1&gt;&gt;filename 同上 command 2&gt;filename 把标准错误重定向到新文件中 command 2&gt;&gt;filename 把标准错误追加到新文件中 输入重定向： 命令 介绍 command &lt;filename 以filename文件作为标准输入 command 0&lt;filename 同上 command &lt;&lt;delimiter 从标准输入中读入，直到遇到delimiter分隔符 &gt;/dev/null 等同于： 1&gt;/dev/null 2&gt;&amp;1 这里用到了重定向绑定，采用&amp;将两个输出绑定到一起 &gt;/dev/null 2&gt;&amp;1 VS 2&gt;&amp;1 &gt;/dev/null linux在执行shell命令之前，就会确定好所有的输入输出位置，并且从左到右依次执行重定向的命令: 命令 标准输出 错误输出 &gt;/dev/null 2&gt;&amp;1 丢弃 丢弃 2&gt;&amp;1 &gt;/dev/null 丢弃 屏幕 &gt;/dev/null 2&gt;&amp;1 VS &gt;/dev/null 2&gt;/dev/null 采用后面这种写法，标准输出和错误输出会抢占往/dev/null文件的管道，所以可能会导致输出内容的时候出现缺失、覆盖等情况,可能出现乱码，也有可能出现只有error信息或者只有正常信息的情况。不管怎么说，采用这种写法，最后的情况是无法预估的。而且，由于out文件被打开了两次，两个文件描述符会抢占性的往文件中输出内容，所以整体IO效率不如&gt;/dev/null 2&gt;&amp;1来得高。 getoptsusage: getopts option_string variable option_string后面跟冒号，代表选项必须带参数 option_string前面带冒号，getopts会区分invalid option和miss option argument错误。 invalid option时，varname被设为?,$OPTAGR是出问题的option; miss option argument时，varname会被设成:,$OPTARG是出问题的option; eval1234567$ foo=10 x=foo$ y='$'$x$ echo $y$foo$ eval y='$'$x$ echo $y10 awk$ echo ‘handsome_feng|shuai’ | awk -F ‘[_|]’ ‘{print $3;}’feng","tags":[],"categories":[{"name":"language","slug":"language","permalink":"https://handsome-feng.github.io/1night-cs/categories/language/"}]},{"title":"docker","date":"2020-05-22T12:03:32.768Z","path":"wiki/linux/docker/","text":"优麒麟创建docker 容器sudo apt install docker.io sudo yum -y install docker-ce // centos sudo systemctl start docker sudo usermod -aG docker feng //重新登陆 docker search ubuntukylin sudo docker pull docker.io/readlnh/ubuntukylin-vnc-docker:19.04-4.18edition 批量创建docker容器： 1234567#!/bin/bashfor i in `seq 1 50`do ((var=5000+i)) docker run --name kylin-1904-$i -m 2G --cap-add ALL --privileged=true -p $var:5900 -td readlnh/ubuntukylin-vnc-docker:19.04-4.18edition /sbin/init echo \"docker run kylin-1904-$i\"done // -p 5000:5900 表示将docker的5000端口和容器的5900端口绑定 docker inspect 查看docker底层信息 进入容器： sudo docker attach ssh nsenter sudo docker exec -it /bin/bash 临时退出一个正在交互的容器终端： ctrl-p ctrl-q 批量删除容器 1sudo docker rm `docker ps -a -q | grep kylin | awk '&#123;print $3&#125;'` 删除镜像 sudo docker rmi docker images -q -a 导入导出镜像： sudo docker images sudo docker save /path/to/kylin-1904.tar sudo docker load /path/to/kylin-1904.tar 在docker中运行优麒麟桌面操作系统我之前在win10刚出wsl的时候好奇去尝试过，当时有一种使用ximage映射使wsl运行图形界面的方案，我猜测docker也可以通过这种类似远程桌面的方式来跑桌面。 同时我又寻找了一些开源项目首先是kde neno，kde neno有docker镜像的试用，看了下发现采用的是xserver-xwphyr这个方案，但是对于docker镜像的细节并看不到，遂放弃。 然后我想到了deepin，似乎曾经听说过他们有相应的docker镜像，我抱着试试看的心态去找了找，发现确实有一个在docker里运行桌面的方案，然而是使用xdocker，这个显然不符合我的预期，只能放弃。 最后终于在github上找到了这个docker-ubuntu-vnc-desktop 这个项目是在docker里运行lxde桌面的ubuntu，并通过浏览器来访问。效果如下 效果相当不错，赶紧看看人家的dockerfile是如何构建的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115# Built with arch: amd64 flavor: lxde image: ubuntu:18.04 localbuild: 1################################################################################## base system################################################################################FROM ubuntu:18.04 as systemRUN sed -i &apos;s#http://archive.ubuntu.com/#http://tw.archive.ubuntu.com/#&apos; /etc/apt/sources.list; # built-in packagesENV DEBIAN_FRONTEND noninteractiveRUN apt update \\ &amp;&amp; apt install -y --no-install-recommends software-properties-common curl apache2-utils \\ &amp;&amp; apt update \\ &amp;&amp; apt install -y --no-install-recommends --allow-unauthenticated \\ supervisor nginx sudo net-tools zenity xz-utils \\ dbus-x11 x11-utils alsa-utils \\ mesa-utils libgl1-mesa-dri \\ &amp;&amp; apt autoclean -y \\ &amp;&amp; apt autoremove -y \\ &amp;&amp; rm -rf /var/lib/apt/lists/*# install debs error if combine togetherRUN add-apt-repository -y ppa:fcwu-tw/apps \\ &amp;&amp; apt update \\ &amp;&amp; apt install -y --no-install-recommends --allow-unauthenticated \\ xvfb x11vnc=0.9.16-1 \\ vim-tiny firefox chromium-browser ttf-ubuntu-font-family ttf-wqy-zenhei \\ &amp;&amp; add-apt-repository -r ppa:fcwu-tw/apps \\ &amp;&amp; apt autoclean -y \\ &amp;&amp; apt autoremove -y \\ &amp;&amp; rm -rf /var/lib/apt/lists/*RUN apt update \\ &amp;&amp; apt install -y --no-install-recommends --allow-unauthenticated \\ lxde gtk2-engines-murrine gnome-themes-standard gtk2-engines-pixbuf gtk2-engines-murrine arc-theme \\ &amp;&amp; apt autoclean -y \\ &amp;&amp; apt autoremove -y \\ &amp;&amp; rm -rf /var/lib/apt/lists/* # Additional packages require ~600MB# libreoffice pinta language-pack-zh-hant language-pack-gnome-zh-hant firefox-locale-zh-hant libreoffice-l10n-zh-tw# tini for subreapARG TINI_VERSION=v0.18.0ADD https://github.com/krallin/tini/releases/download/$&#123;TINI_VERSION&#125;/tini /bin/tiniRUN chmod +x /bin/tini# ffmpegRUN mkdir -p /usr/local/ffmpeg \\ &amp;&amp; curl -sSL https://johnvansickle.com/ffmpeg/releases/ffmpeg-release-amd64-static.tar.xz | tar xJvf - -C /usr/local/ffmpeg/ --strip 1# python libraryCOPY image/usr/local/lib/web/backend/requirements.txt /tmp/RUN apt-get update \\ &amp;&amp; dpkg-query -W -f=&apos;$&#123;Package&#125;\\n&apos; &gt; /tmp/a.txt \\ &amp;&amp; apt-get install -y python-pip python-dev build-essential \\ &amp;&amp; pip install setuptools wheel &amp;&amp; pip install -r /tmp/requirements.txt \\ &amp;&amp; dpkg-query -W -f=&apos;$&#123;Package&#125;\\n&apos; &gt; /tmp/b.txt \\ &amp;&amp; apt-get remove -y `diff --changed-group-format=&apos;%&gt;&apos; --unchanged-group-format=&apos;&apos; /tmp/a.txt /tmp/b.txt | xargs` \\ &amp;&amp; apt-get autoclean -y \\ &amp;&amp; apt-get autoremove -y \\ &amp;&amp; rm -rf /var/lib/apt/lists/* \\ &amp;&amp; rm -rf /var/cache/apt/* /tmp/a.txt /tmp/b.txt################################################################################# builder################################################################################FROM ubuntu:18.04 as builderRUN sed -i &apos;s#http://archive.ubuntu.com/#http://tw.archive.ubuntu.com/#&apos; /etc/apt/sources.list; RUN apt-get update \\ &amp;&amp; apt-get install -y --no-install-recommends curl ca-certificates gnupg patch# nodejsRUN curl -sL https://deb.nodesource.com/setup_8.x | bash - \\ &amp;&amp; apt-get install -y nodejs# yarnRUN curl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | apt-key add - \\ &amp;&amp; echo &quot;deb https://dl.yarnpkg.com/debian/ stable main&quot; | tee /etc/apt/sources.list.d/yarn.list \\ &amp;&amp; apt-get update \\ &amp;&amp; apt-get install -y yarn# build frontendCOPY web /src/webRUN cd /src/web \\ &amp;&amp; yarn \\ &amp;&amp; npm run build################################################################################# merge################################################################################FROM systemLABEL maintainer=&quot;fcwu.tw@gmail.com&quot;COPY --from=builder /src/web/dist/ /usr/local/lib/web/frontend/COPY image /EXPOSE 80WORKDIR /rootENV HOME=/home/ubuntu \\ SHELL=/bin/bashHEALTHCHECK --interval=30s --timeout=5s CMD curl --fail http://127.0.0.1:6079/api/healthENTRYPOINT [&quot;/startup.sh&quot;] 发现这个镜像是从最基础的ubuntu18.04开始构建的，然后安装桌面对应的包。然后很关键的，安装了xvfb和x11vnc这两个包。xvfb是虚拟显卡，x11vnc则是用来提供x11服务的，以便主机通过x11客户端来访问桌面。 继续往下看，略过那些库，还有两个重要的操作，一个是把上下文中的web后端部署到docker中，但是我并不清楚开源社会采用什么方案，我理解里应该只需要提供相应的vnc端口即可，所以这一步没什么必要。另一个则是ADD https://github.com/krallin/tini/releases/download/${TINI_VERSION}/tini /bin/tini我去到github项目主页下发现这是个用来初始化并启动系统的项目，但是似乎新版的docker已经自带这个功能？于是乎思路已经基本定了，在docker的系统中安装xvfb和x11vnc,用xvfb虚拟显卡，通过x11vnc提供显示服务。 制作过程等等，一般的docker镜像制作都是从基础镜像开始构建的，但是我并不清楚优麒麟需要哪些包…这下子尴尬了。好在docker可以通过导入tar包来制作镜像。我找了一台已经安卓ubuntukylin19.04增强版的机器，把根目录下除了启动时自动生成的那些目录打包到一个tar包里，最后导入到docker制作成镜像。 1tar -cvpf /tmp/system.tar --directory=/ --exclude=proc --exclude=sys --exclude=dev --exclude=run --exclude=boot . 其中/proc、/sys、/run、/dev这几个目录都是系统启动时自动生成的，虽然也属于文件系统一部分，但是他们每次开机都会有变化，所以打包的时候就应该忽略它们。然后执行 1cat system.tar | docker import - ubuntukylin:19.04 这样，镜像就制作完毕了。 接下来运行docker，恩？什么都没有发生？？？进入容器一看，发现ligtdm根本没有启动，这就很尴尬了…找了半天问题，没什么头绪，大概猜测和systemd有关，一不做二不休，手动启动ukui-session！恩？什么情况，我的桌面怎么没了，被docker内的ukui占用了，开始运行开机动画？我进到容器里查看，发现/dev目录下挂载了宿主机的设备，去看了下runc的源码，最后得出的结论是systemd的改动，使得某些目录变成shared by default，所以主机显卡被docker占用了导致主机桌面挂掉了…吸取教训，先把/dev的挂载点删了再启动…结果卡在登录进不去？？？然后同事说ukui-greeter出了bug，但是作者上周刚刚才离职了…行吧，不要登录锁屏了，直接把这个包卸载了。ok，终于成功的进了桌面，等等，窗口管理器怎么不见了，鼠标变成x了，想了想发现是自己头脑混乱了，在管理员权限下启动了桌面，用su lm(用户名),切换到普通用户lm，终于正常了。 但是我不能每次都手动去启动吧，必须在启动时自动执行脚本才行，于是在/etc新建了一个rc.local脚本，每次先删除设备节点，然后通过xvfb创建虚拟显卡，设置显示区域，切换到普通用户并执行runsession脚本(chmod + x) 12345678910111213#!/bin/bashrm /dev/fb0rm -rf /dev/driexport DISPLAY=:1Xvfb :1 -screen 0 1024x768x16 &gt; /opt/xvfb.log 2&gt;&amp;1 &amp;su lm -c /home/lm/runsessionsleep 10su lm -c /home/lm/runukwm runsession脚本 12345678910111213141516#!/bin/shexport DISPLAY=:1DISPLAY=:1 x11vnc -display :1 -forever -bg -nopw -xkb#sleep 30export QT4_IM_MODULE=fcitx export QT_IM_MODULE=fcitx export XMODIFIERS=@im=fcitx export GTK_IM_MODULE=fcitx /usr/bin/fcitxQT4_IM_MODULE=fcitx QT_IM_MODULE=fcitx XMODIFIERS=@im=fcitx GTK_IM_MODULE=fcitx DISPLAY=:1 ukui-session &gt; /home/lm/ukui-session.log 2&gt;&amp;1 &amp; 1234#!/bin/bashexport DISPLAY=:1XDG_SESSION_TYPE=x11 DISPALY=:1 UKWM_VERBOSE=1 ukwm -r &gt; /home/lm/ukwm.log 2&gt;&amp;1 &amp; 脚本里主要就是启动了x11vnc设置了一些默认参数，最后启动ukui-session。这里要注意的是，rc.local执行脚本的时候会缺失很多环境变量，必须在脚本里指定，否则会导致一些异常行为。 禁用plymouth相关服务 1find -name *plymouth*.service 全删了即可 至此，docker镜像完成了。 运行结果执行 1docker run --name test1(容器名) --cap-add ALL --privileged=true -td readlnh/ubuntukylin-vnc-docker:19.04 /sbin/init 创建并启动容器使用如下命令查看ip地址 1docker inspect test1(容器名) 最后通过vncview来连接 1vncviewer 172.17.0.2(容器ip):5900(默认端口) 效果如下","tags":[],"categories":[{"name":"linux","slug":"linux","permalink":"https://handsome-feng.github.io/1night-cs/categories/linux/"}]},{"title":"","date":"2020-05-22T12:03:32.768Z","path":"wiki/linux/file_system/","text":"=== title: file systemext文件系统 0~1: 引导扇区 2~3: 超级块 组描述符表 块位图表 inode位图表 inode节点表 数据区 zfs (Z File System) 存储池 写时拷贝 快照 数据完整性验证和自动修复 RAID-Z 巨大的容量","tags":[],"categories":[{"name":"linux","slug":"linux","permalink":"https://handsome-feng.github.io/1night-cs/categories/linux/"}]},{"title":"","date":"2020-05-22T12:03:32.768Z","path":"wiki/linux/graphics_system/","text":"Prefrence: https://www.cnblogs.com/shoemaker/p/linux_graphics01.html","tags":[],"categories":[{"name":"linux","slug":"linux","permalink":"https://handsome-feng.github.io/1night-cs/categories/linux/"}]},{"title":"","date":"2020-05-22T12:03:32.768Z","path":"wiki/linux/initrd/","text":"————————————————版权声明：本文为CSDN博主「geekard」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/geekard/article/details/6455502","tags":[],"categories":[{"name":"linux","slug":"linux","permalink":"https://handsome-feng.github.io/1night-cs/categories/linux/"}]},{"title":"Kernel","date":"2020-05-22T12:03:32.768Z","path":"wiki/linux/kernel/","text":"内核开发特点无libc库或无标准头文件内核代码中所使用的C语言扩展： 內联函数 static inline void wolf(unsigned long tail_size) 由于使用了static,编译时不会为內联函数单独建立一个函数体 內联汇编 使用asm()插入汇编代码 12345unsigned int log, high;asm volatile(&quot;rdtsc&quot; : &quot;=a&quot; (low), &quot;=d&quot; (high));/* low 和 high 分别包含64位时间戳的低32位和高32位 */ 分支声明 1234567/* 我们认为error绝大多数时间都会为0... */if (unlikely(error)) &#123;​ /* ... */&#125; 没有内存保护机制不要轻易在内核中使用浮点数进程管理写时拷贝：资源的复制只在需要写入的时候才进行，在此之前，以只读形式共享 fork clone (SIGCHLD, 0) vfork clone (CLONE_VFORK | CLONE_VM | SIGCHLD, 0); 线程 clone (CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, 0); 内核线程 c语言编译器会在main()函数的返回点后面放置调用exit()的代码 终结进程大部分靠do_exit()， do_exit()永不返回 与进程相关联的所有资源被释放后，进程不可运行并处于EXIT_ZOMBIE退出状态，占用的所有内存就是内核栈、thread_info结构和tast_struct结构。 进程调度完全公平调度算法 CFS 查看NI(nice值) ps -el 查看实时优先级 ps -eo state,uid,pid,ppid,rtprio,time,comm","tags":[],"categories":[{"name":"linux","slug":"linux","permalink":"https://handsome-feng.github.io/1night-cs/categories/linux/"}]},{"title":"kvm","date":"2020-05-22T12:03:32.768Z","path":"wiki/linux/kvm/","text":"检查是否支持硬件虚拟化： $ egrep -c ‘(vmx|svm)’ /proc/cpuinfo #(&gt;=1则支持) 或 $ kvm-ok 安装依赖： $ sudo apt install qemu-kvm libvirt-clients qemu-utils libvirt-daemon-system 启动libvertd服务： $ sudo systemctl enable libvirtd $ sudo systemctl start libvirtd In order to be able to manage virtual machines as regular user, that user needs to be added to some groups: $ sudo add user feng libvirt $ sudo add user feng libvirt-qemu 设置网络桥接： $ sudo vim /etc/network/interfaces 1234567891011auto loiface lo inet loopbackauto br0iface br0 inet dhcpbridge_ports enp2s0 //enp2s0 is the name of your interface 创建一个vm: sudo virt-install –name kylin-1904 –memory 2048 –vcpus 1 –disk size=12 –cdrom /home/feng/ubuntukylin-1904-enhanced-desktop-amd64.iso –graphics vnc,listen=0.0.0.0 –noautoconsole –bridge br0 客户端通过remmina连接，并完成安装： vnc: 10.0.0.100:5900 克隆vm: $ sudo virt-clone -o kylin-1904 -n kylin-1904-1 -f /var/lib/libvirt/images/kylin-1904-1.qcow2 批量克隆： 1234567#!/bin/bashfor i in `seq 1 50`dovirt-clone -o kylin-1904 -n kylin-1904-$i -f /var/lib/libvirt/images/kylin-1904-$i.qcow2echo \"copying $i...\"done 配置文件路径： /etc/libvirt/qemu 查看vnc端口号： $ sudo virsh dumpxml kylin-1904 | grep vnc 或者 $ sudo virsh vncdisplay kylin-1904 管理VMs: sudo virsh list –all sudo virsh start kylin-19.04 sudo virsh suspend kylin-19.04 sudo virsh resume kylin-19.04 sudo virsh shutdown kylin-19.04 sudo virsh undefine kylin-19.04 sudo virsh destroy kylin-19.04","tags":[],"categories":[{"name":"linux","slug":"linux","permalink":"https://handsome-feng.github.io/1night-cs/categories/linux/"}]},{"title":"","date":"2020-05-22T12:03:32.768Z","path":"wiki/linux/linux_c/","text":"Linux C 进阶之路 标签（空格分隔）： linux 性能调优 熟练掌握STL，boost 设计模式 MySQL数据库,SQL 调优 高并发分布式系统 熟悉分布式技术，如RPC、负载均衡、高可用、消息系统、缓存技术等 熟悉Linux系统用户层程序编写(共享内存、posix线程、信号量) 精通Linux系统用户层程序调试技术(gdb,strace,mtrace,ltrace) 熟悉socket编程，了解TCP/IP协议族； openstack,kvm或docker等虚拟化技术/项目开发经验的同学优先 linux c/c++ 细节常用关键字volatilevolatile的作用是作为指令关键字，确保本条指令不会因编译器的优化而省略，且要求每次直接读值。 volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。 常用函数sizeof &amp; strlensizeof是运算符，在编译时计算，不能用来返回动态分配的内存空间的大小。 strlen是函数，运行时计算，计算字符串的长度，以0x00作为结束符。 浮点数如何比较fabs(a-b)&lt;=1E-6 结构体如何比较c: 逐一比较结构体内容c++: 重载”=”运算符 fopen参数FILE *fopen(const char *pathname, const char *mode); Thread safety C++面向对象友元类：实际上具体大概有下面两种情况需要使用友元函数：（1）运算符重载的某些场合需要使用友元。（2）两个类要共享数据的时候。 如何获取文件大小 使用fseek, ftell: 12345678char *file = \"/home/feng/time.log\";FILE *fp = fopen (file, \"r\"); //文件需要先读入内存, 所以效率低if (!fp) return -1;fseek(fp, 0L, SEEK_END);long size = ftell(fp); //因为返回值为long, 所以超过这个大小的文件无法用这种方法fclose(fp);printf(\"%s's size: %ld\\n\",file, size); 使用stat 1234struct stat statbuf;stat(file, &amp;statbuf);int size2 = statbuf.st_size;printf(\"%s's size: %d\\n\",file, size2) setuid, setgid, strick bitsetuid的作用是“让执行该命令的用户以该命令拥有者的权限去执行”，比如普通用户执行passwd时会拥有root的权限，就可以修改/etc/passwd这个文件了。setgid的作用是让执行文件的用户以该文件所属组的权限去执行。strick bit是针对目录来说的，如果该目录设置了stick bit（粘滞位），则该目录下的文件除了该文件的创建者和root用户可以删除和修改，别的用户均不能动。 123456chmod u+s xxx # 设置setuid权限chmod g+s xxx # 设置setgid权限chmod o+t xxx # 设置stick bit权限，针对目录chmod 4775 xxx # 设置setuid权限chmod 2775 xxx # 设置setgid权限chmod 1775 xxx # 设置stick bit权限，针对目录 注意：有时你设置了s或t 权限，你会发现它变成了S或T，这是因为在那个位置上你没有给它x（可执行）的权限，这样的话这样的设置是不会有效的，你可以先给它赋上x的权限，然后再给s或t 的权限。 虚函数内存对齐char可起始于任意字节地址2字节的short必须从偶数字节地址开始4字节的int或float必须从能被4整除的地址开始8字节的long和double必须从能被8整除的地址开始。无论signed（有符号）还是unsigned（无符号）都不受影响。x86和ARM上的基本C类型是“自对齐（self-aligned）”的。关于指针，无论32位（4字节）还是64位（8字节）也都是自对齐的。通常情况下，结构体实例以其最宽的标量成员为基准进行对齐。结构体的长度是其最宽成员长度的整数倍 结构体每个成员相对于起始地址的偏移能够被其自身大小整除，如果不能则在前一个成员后面补充字节 结构体总体大小能够被最宽的成员的大小整除，如不能则在后面补充字节 可以通过#pragma pack x强迫编译器采用x的对齐规则 参考: The lost art of c structure packing malloc、free与new、delete区别 Feature new/delete malloc/free Memory allocated from ‘Free Store’ ‘Heap’ Returns Fully typed pointer void* On failure Throws (never returns NULL) Returns NULL Required size Calculated by compiler Must be specified in bytes Handling arrays Has an explicit version Requires manual calculations Reallocating Not handled intuitively Simple (no copy constructor) Call of reverse Implementation defined No Low memory cases Can add a new memory allocator Not handled by user code Overridable Yes No Use of (con-)/destructor Yes No delete和delete[]区别对于内置类型，new[]&lt;-&gt;delete[] 怎么对应都不会有问题，free 只需要一个首地址，通过指针偏移可以获取到下一个内存块和上一个内存的地址，把这个内存块从链表中删除就 ok 了。对于类对象数组，赋值过程中编译器做了一些 free 层面不知道的偏移，所以一旦 new[] 和 delete[] 不对应，会发生崩溃。 拷贝构造函数当对对象进行拷贝时不是做简单的对象的值的拷贝而应该将堆中的数据也进行拷贝，这种拷贝模式叫做深拷贝 在linux下写计时器秒级别： clock() //c语言库函数毫秒级：timeval starttime,endtime;​ gettimeofday(&amp;starttime,0); //do some process here gettimeofday(&amp;endtime,0); unsigned int a,b; double c=a*b 会不会溢出为什么析构函数要用虚析构函数c的内存分布12345678910111213141516int a = 0; /* a在全局已初始化数据区 */char *p1; /* p1在BSS区(未初始化全局变量) */int main() &#123; int b; /* b在栈区 */ char s[] = “abc”; /* s为数组变量, 存储在栈区 */ /* “abc”为字符串常量, 存储在已初始化数据区 */ char *p1, p2; /* p1, p2在栈区 */ char *p3 = “123456”; /* “123456\\0″已初始化在数据区, p3在栈区 */ static int c = 0; /* c为全局(静态)数据, 存在于已初始化数据区 */ /* 另外, 静态数据会自动初始化 */ p1 = (char *)malloc(10); /* 分配的10个字节的区域存在于堆区 */ p2 = (char *)malloc(20); /* 分配的数据位于堆区 */ free(p1); free(p2);&#125; BSS(Block Started by Symblo)存放未初始化的全局变量和静态局部变量（程序加载时，BSS被操作系统清零）数据段（Data）存放已初始化的全局变量和静态局部变量数据段与BSS段区别： BSS段不占用物理文件尺寸，但占用内存空间；数据段占用物理文件，也占用内存空间。对于大型数组如int ar0[10000] = {1, 2, 3, …}和int ar1[10000]，ar1放在BSS段，只记录共有10000*4个字节需要初始化为0，而不是像ar0那样记录每个数据1、2、3…，此时BSS为目标文件所节省的磁盘空间相当可观。 当程序读取数据段的数据时，系统会出发缺页故障，从而分配相应的物理内存；当程序读取BSS段的数据时，内核会将其转到一个全零页面，不会发生缺页故障，也不会为其分配相应的物理内存。 静态变量僵尸进程在fork()/execve（）过程中，假设子进程结束时父进程仍存在，而父进程fork()之前既没安装SIGCHLD信号处理函数调用waitpid()等待子进程结束，又没有显式忽略该信号，则子进程成为僵尸进程，无法正常结束。此时即使是root身份kill -9 也不能杀死僵尸进程。解决大批量僵尸简单有效的办法是重起。或者杀死僵尸进程的父进程（僵尸进程的父进程必然存在），僵尸进程成为”孤儿进程”，过继给1号进程init，init始终会负责清理僵尸进程。 僵尸进程的避免： 父进程通过wait和waitpid等函数等待子进程结束，这会导致父进程挂起。 如果父进程很忙，那么可以用signal函数为SIGCHLD安装handler，因为子进程结束后， 父进程会收到该信号，可以在handler中调用wait回收。 如果父进程不关心子进程什么时候结束，那么可以用signal（SIGCHLD,SIG_IGN） 通知内核，自己对子进程的结束不感兴趣，那么子进程结束后，内核会回收， 并不再给父进程发送信号。 还有一些技巧，就是fork两次，父进程fork一个子进程，然后继续工作，子进程fork一个孙进程后退出，那么孙进程被init接管，孙进程结束后，init会回收。不过子进程的回收 还要自己做。 123/* Reap any outstanding zombies that we may have inherited */while (waitpid (-1, &amp;status, WNOHANG) &gt; 0) ; 线程从 Linux 内核的角度来说，其实它并没有线程的概念。Linux 把所有线程都当做进程来实现，它将线程和进程不加区分的统一到了task_struct中。线程仅仅被视为一个与其他进程共享某些资源的进程，，而是否共享地址空间几乎是进程和 Linux 中所谓线程的唯一区别。线程创建的时候，加上了 CLONE_VM 标记，这样 线程的内存描述符 将直接指向 父进程的内存描述符。 线程与进程区别 进程是资源分配的基本单位，线程是程序执行的最小单位，或者说cpu调度的最小单位。 进程有独立的地址空间，而一个进程中的线程之间共享大部分数据，使用相同的地址空间，线程拥有自己的局部变量和堆栈（注意不是堆）。 同一进程内的所有线程共享： 全局变量 进程指令 大多数数据 打开的文件（即描述符） 信号处理函数和信号处置 当前工作目录 用户ID和组ID但是有各自的： 线程ID 寄存器集合，包括程序计数器和栈指针 栈（用于存放局部变量和返回地址） errno 信号掩码 优先级 互斥锁条件变量 并发 竞态 死锁 互斥锁 自旋锁 读写自旋锁 顺序锁 RCU 信号量 中断屏蔽 原子操作 进程间通讯pipeeventfdhttps://www.jianshu.com/p/57cc1d7d354feventfd类似于管道的概念，可以实现线程间的事件通知，类似于pipe。而eventfd 是一个比 pipe 更高效的线程间事件通知机制，一方面它比 pipe 少用一个 file descriper，节省了资源；另一方面，eventfd的缓冲区管理也简单得多，全部“buffer”一共只有8字节，不像pipe那样可能有不定长的真正buffer。eventfd的缓冲区大小是sizeof(uint64_t)也就是8字节，它是一个64位的计数器，写入递增计数器，读取将得到计数器的值，并且清零。 信号1int sigprocmask(int how, const sigset_t *set, sigset_t *oldset); 调用函数sigprocmask可以检测或更改其信号屏蔽字 while (waitpid (-1, &amp;status, WNOHANG) &gt; 0) 操作系统内核态与用户态用户态的应用程序访问内核态的资源： 系统调用 库函数 Shell脚本 用户态切换到内核态的3中方式： 系统调用 （软中断，int 80h） 异常当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。 外围设备的中断当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等 系统命令定时任务crontab/var/spool/cron/crontabs","tags":[],"categories":[{"name":"linux","slug":"linux","permalink":"https://handsome-feng.github.io/1night-cs/categories/linux/"}]},{"title":"Network","date":"2020-05-22T12:03:32.768Z","path":"wiki/linux/network/","text":"Unix errno值只要一个Unix函数中有错误发生,全局变量errno就被置为一个指明该错误类型的正值,函数本身则通常返回-1. 网络拓扑的发现123$ netstat -ni //-i提供网络接口信息,-n标志输出数值地址$ netstat -nr // -r展示路由表$ ifconfig // 获取各个接口详细信息 找出本地网络众多主机的IP地址方法之一是针对本地接口的广播地址执行ping命令: 1$ ping -b 192.168.255.255 tcp三次握手 ####假设A为客户端,B为服务器端: 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求. A 向 B 发送连接请求报文段，SYN=1，ACK=0，选择一个初始的序号 x. B 收到连接请求报文段，如果同意建立连接，则向A发送连接确认报文段，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y. A 收到 B 的连接确认报文段后，还要向 B 发出确认，确认号为 y+1，序号为 x+1. B 收到 A 的确认后，连接建立。 三次握手的原因第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。失效的连接请求是指，客户端发送的连接请求在网络中滞留，客户端因为没及时收到服务器端发送的连接确认，因此就重新发送了连接请求。滞留的连接请求并不是丢失，之后还是会到达服务器。如果不进行第三次握手，那么服务器会误认为客户端重新请求连接，然后打开了连接。但是并不是客户端真正打开这个连接，因此客户端不会给服务器发送数据，这个连接就白白浪费了。 tcp四次挥手 ####以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为1. A 发送连接释放报文段，FIN=1。 B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。 当 B 不再需要连接时，发送连接释放请求报文段，FIN=1。 A 收到后发出确认，进入 TIME-WAIT 状态，等待 2MSL 时间后释放连接。 B 收到 A 的确认后释放连接。 四次挥手的原因客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。 TIME_WAIT客户端（主动关闭的一端）接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间2MSL(最长分节生命期的2倍)。每个数据报有一个称为跳限(hop limit)的8位字段，最大值为255.这么做有两个理由： 可靠地实现TCP全双工连接的终止：假设客户端最终的ACK丢失了，服务器将重新发送最终那个FIN，因此客户端必须维护状态信息，以便重新发送最终的那个ACK。 允许老的重复分节在网络中消逝：等待一段时间是为了让本连接持续时间内所产生的所有报文段都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文段。 捎带：服务器对客户请求的确认时伴随其应答发送的，但是如果服务器耗时大于200ms，那么我们将看到先是确认后是应答。 SCTP四路握手： 避免拒绝服务攻击 端口号 0~1023 //众所周知的端口，有IANA(因特网已分配数值权威机构)分配和控制 1024~49151 //已登记的端口 49152～65535 //动态的或私用的(49152时65535的3/4) 标识每个端点的两个值(IP地址和端口号)通常称为一个套接字。 MSS:最大分节大小，用户向对端TCP通告对端在每个分节中能发送的最大TCP数据量。通常设置为： MTU - IP首部固定长度 - TCP首部固定长度 1in_addr_r inet_addr(const char *strptr); //已废弃 当出错时返回INADDR_NONE常值(32位均为1的值)，所以该函数不能处理255.255.255.255 若connect失败，则该套接字不可再用，必须关闭。值结果参数 HTTPPOST和GET请求方法的区别 参数：GET的参数以查询字符串出现在URL中，而POST的参数存储在内容尸体中。 安全：安全的HTTP方法不会改变服务器的状态，是只读的，GET方法是安全的，POST不是，POST的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，可能存储在服务器数据库中。 幂等性：幂等的HTTP方法，同样的请求被执行一次与连续多次的效果是一样的，服务器的状态也是一样的。GET,HEAD,PUT,DELETE是幂等的，POST不是。 可缓存：如果要对响应进行缓存，需要满足以下条件：a. 请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。b. 响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。c. 响应报文的 Cache-Control 首部字段没有指定不进行缓存。 fork和exec函数父进程中调用fork之前打开的所有描述符在fork返回后由子进程分享。子进程接着读这个已连接套接字，父进程则关闭这个已连接套接字。进程在调用exec之前打开着的描述符通常跨exec继续保持打开，但是可以使用fcntl设置FD_CLOEXEC描述符标志禁止掉。 描述符引用计数引用计数大于0,则close调用并不引发TCP的四分组连接终止序列。如果确实想在TCP连接上发送一个FIN,那么可以用shutdown函数。 1ps -a -o pid,ppid,stat,args,wchan SIGKILL和SIGSTOP不能被捕获和忽略 如果一个信号在被阻塞期间产生了一次或多次，那么该信号在被解阻塞之后通常只递交一次，也就是说Unix信号默认时不排队的。 对于返回值为void的信号处理函数,依然使用return; 语句, 这样,当某个系统调用被我们编写的某个信号处理函数中断时,我们就可以得知改系统调用具体是被哪个信号处理函数的哪个return语句中断的. 当connect被一个捕获的信号中断而且不自动重启时,我们必须调用select来等待连接完成. 二三层交换select函数maxfdp1: 是待测试的最大描述符+1如果readset, writeset, exceptset三个指针均为空，就有了一个比Unix的sleep函数更精确的定时器。 recv使用过程中的问题select最大并发量​ 应用层 运输层 网络层 链路层 网桥在链路层对网络进行互联 路由器在网络层对网络进行互联 5类互联网地址 grep telnet /etc/services 标准的服务端口号都是奇数，因为从NCP(单工，每个应用程序需要两个连接)端口号派生出来。 Internet: 世界范围内通过TCP/IP互相通信的所有主机集合 internet: 用一个共同的协议族把多个网络连接在一起 链路层SLIP: 串行线路IP 缺点： 每一端必须知道对方的IP 数据帧中没有类型字段 没有在数据帧中加上校验和 PPP: 点对点协议 环回接口 最大传输单元MTU 路径MTU netstat -i IP: 网际协议使用源路由选项，IP地址可能被修改 ARP使用委托ARP的线索：同一个子网上的两台主机IP地址映射的硬件地址相同 tcpdumpping利用ICMP回显请求和回显报文，不用经过传输层(TCP/UDP) Traceroute利用ICMP报文和IP首部中的TTL字段（生存周期），开始时，发送一个TTL字段为1的UDP数据报，然后将TTL字段每次加1，通过区分接收到的ICMP报文是超时还是端口不可达，以判断什么时候结束 网络抓包tcpdump 抓包wireshark 分析抓到的包 ssss 是 Socket Statistics 的缩写。ss 命令可以用来获取 socket 统计信息，它显示的内容和 netstat 类似。但 ss 的优势在于它能够显示更多更详细的有关 TCP 和连接状态的信息，而且比 netstat 更快。 常用选项: -h, –help 帮助-V, –version 显示版本号-t, –tcp 显示 TCP 协议的 sockets-u, –udp 显示 UDP 协议的 sockets-x, –unix 显示 unix domain sockets，与 -f 选项相同-n, –numeric 不解析服务的名称，如 “22” 端口不会显示成 “ssh”-l, –listening 只显示处于监听状态的端口-p, –processes 显示监听端口的进程(Ubuntu 上需要 sudo)-a, –all 对 TCP 协议来说，既包含监听的端口，也包含建立的连接-r, –resolve 把 IP 解释为域名，把端口号解释为协议名称","tags":[],"categories":[{"name":"linux","slug":"linux","permalink":"https://handsome-feng.github.io/1night-cs/categories/linux/"}]},{"title":"","date":"2020-05-22T12:03:32.768Z","path":"wiki/linux/sharedlibs/","text":"The following command, when run on a shared library, will output the name to be used for the Debian package containing that shared library: 123objdump -p /usr/lib/x86_64-linux-gnu/libGLU.so.1.3.1 \\ | sed -n -e&apos;s/^[[:space:]]*SONAME[[:space:]]*//p&apos; \\ | LC_ALL=C sed -r -e&apos;s/([0-9])\\.so\\./\\1-/; s/\\.so(\\.|$)//; y/_/-/; s/(.*)/\\L&amp;/&apos; It is recommended that supporting files and run-time support programs that do not need to be invoked manually by users, but are nevertheless required for the package to function, be placed (if they are binary) in a subdirectory of /usr/lib, preferably under /usr/lib/package-name. If the program or file is architecture independent, the recommendation is for it to be placed in a subdirectory of /usr/share instead, preferably under /usr/share/package-name. Following the package-name naming convention ensures that the file names change when the shared object version changes. symbols files are therefore recommended for most shared library packages since they provide more accurate dependencies. For most C libraries, the additional detail required by symbols files is not too difficult to maintain. However, maintaining exhaustive symbols information for a C++ library can be quite onerous, so shlibs files may be more appropriate for most C++ libraries. Libraries with a corresponding udeb must also provide a shlibs file, since the udeb infrastructure does not use symbols files. dpkg-shlibdepsdpkg-shlibdeps will use a program like objdump or readelf to find the libraries and the symbols in those libraries directly needed by the binaries or shared libraries in the package. The easiest way to call dpkg-shlibdeps correctly is to use a package helper framework such as debhelper. If you are using debhelper, the dh_shlibdeps program will do this work for you. It will also correctly handle multi-binary packages. ${shlibs:Depends} The symbols systemThe shlibs systemhttps://www.debian.org/doc/debian-policy/ch-sharedlibs.html A shared library is identified by the SONAME attribute stored in its dynamic section. When a binary is linked against a shared library, the SONAME of the shared library is recorded in the binary’s NEEDED section so that the dynamic linker knows that library must be loaded at runtime. The shared library file’s full name (which usually contains additional version information not needed in the SONAME) is therefore normally not referenced directly. Instead, the shared library is loaded by its SONAME, which exists on the file system as a symlink pointing to the full name of the shared library.","tags":[],"categories":[{"name":"linux","slug":"linux","permalink":"https://handsome-feng.github.io/1night-cs/categories/linux/"}]},{"title":"Snap","date":"2020-05-22T12:03:32.768Z","path":"wiki/linux/snap/","text":"1234567891011$ sudo snap ack ubuntu-core_1797.assert$ sudo snap install ubuntu-core_1797.snap$ sudo snap ack somePackage.assert$ sudo snap install somePackage.snap$ sudo snap install --dangerous some.snap$ sudo snap revert hello$ snap changes$ sudo snap abort id 12345678910$ sudo apt install apparmor apparmor-utils$ sudo mkdir -p /etc/default/grub.d$ echo &apos;GRUB_CMDLINE_LINUX_DEFAULT=&quot;$GRUB_CMDLINE_LINUX_DEFAULT apparmor=1 security=apparmor&quot;&apos; \\ | sudo tee /etc/default/grub.d/apparmor.cfg$ sudo update-grub$ sudo reboot$ sudo aa-status$ ps auxZ | grep -v &apos;^unconfined&apos; $ xdelta3 -s telegram-desktop_637.snap telegram-desktop_617.snap telegram-desktop_637.snap.xdelta3 查看SELinux状态： 1、/usr/sbin/sestatus -v ##如果SELinux status参数为enabled即为开启状态 SELinux status: enabled 2、getenforce ##也可以用这个命令检查 关闭SELinux： 1、临时关闭（不用重启机器）： setenforce 0 ##设置SELinux 成为permissive模式 ​ ##setenforce 1 设置SELinux 成为enforcing模式 2、修改配置文件需要重启机器： 修改/etc/selinux/config 文件 将SELINUX=enforcing改为SELINUX=disabled 重启机器即可","tags":[],"categories":[{"name":"linux","slug":"linux","permalink":"https://handsome-feng.github.io/1night-cs/categories/linux/"}]},{"title":"","date":"2020-05-22T12:03:32.768Z","path":"wiki/linux/swap/","text":"创建一个空文件，具体大小的话对于小内存机器建议为内存的两倍 (例子中 1K * 4M = 4 GiB).sudo mkdir -v /var/cache/swapcd /var/cache/swapsudo dd if=/dev/zero of=swapfile bs=1K count=4Msudo chmod 600 swapfile 将新建的文件转换为 swap 文件.sudo mkswap swapfile 开启 swap.sudo swapon swapfile 通过 swapon 或者 top 命令进行验证:swapon -s 或者top -bn1 | grep -i swap 会显示类似信息: KiB Swap: 4194300 total, 4194300 free禁用 swap 时可以使用 sudo swapoff swapfile.将该分区设置成开机加载.echo “/var/cache/swap/swapfile none swap sw 0 0” | sudo tee -a /etc/fstab 测试开机加载:sudo swapoff swapfilesudo swapon -va","tags":[],"categories":[{"name":"linux","slug":"linux","permalink":"https://handsome-feng.github.io/1night-cs/categories/linux/"}]},{"title":"","date":"2020-05-22T12:03:32.768Z","path":"wiki/linux/sysrq/","text":"https://fedoraproject.org/wiki/QA/Sysrq https://www.kernel.org/doc/html/latest/admin-guide/sysrq.html","tags":[],"categories":[{"name":"linux","slug":"linux","permalink":"https://handsome-feng.github.io/1night-cs/categories/linux/"}]},{"title":"systemd","date":"2020-05-22T12:03:32.768Z","path":"wiki/linux/systemd/","text":"multi-SeatDefinition of Terms seat: consists of all hardware devices assigned to a specific workplace. At least one graphics device, and usually also includes keyboard, mouse. It can also include video cameras, sound cards and more. session: It is defined by the time a user is logged in until he logs out. A session is bound to one or no seats(for ‘virtual’ ssh logins). Multiple sessions can be attached to the same seat, but only one of them can be active. user: Corresponds to the person using a computer, identified by a numeric user id(UID) or a user name(string). multi-session: A system allows multiple user sessions on the same seat at the same time. multi-seat: A system allows multiple independent seats that can be individually and simultaneously used by different user. Note: hardware like printers, hard disks or network cards is generally not assigned to a specific seat. They are available to all seats equally. (Well, with one exception: USB sticks can be assigned to a seat) “seat0” always exists. udev RulesAssignment of hardware devices to seats is managed inside the udev database, via settings on the devices: Tag “seat”: if set this device is eligible to be assigned to a seat. Tag “master-of-seat” Property “ID_SEAT” Property “ID_AUTOSEAT” Property “ID_FOR_SEAT” Examples123loginctl list-seatsloginctl seat-status seat0loginctl attach // assign hardware to a specific seat Configuration/etc/systemd/system.conf DebuggingReference: https://freedesktop.org/wiki/Software/systemd/Debugging","tags":[],"categories":[{"name":"linux","slug":"linux","permalink":"https://handsome-feng.github.io/1night-cs/categories/linux/"}]},{"title":"","date":"2020-05-22T12:03:32.768Z","path":"wiki/others/projects/","text":"项目flatpak基本概念：运行时(runtimes):“运行时”提供应用程序所需的基本依赖。有各种各样的“运行时”,比如“Freedesktop运行时”，“GNOME运行时”。“Freedesktop运行时”包含一系列必要的库和服务，包括D-Bus, GLib, PulseAudio, X11和Wayland等。“GNOME运行时”基于“FreeDesktop运行时”，增加了一些GNOME平台相关的库，比如GStreamer,GTK+,GVFS等。必须针对运行时构建每个应用程序，并且必须在主机系统上安装此运行时才能运行应用程序。用户可以同时安装多个不同的运行时，包括不同版本的同一个运行时。 每一个运行时可以看做一个’/usr’ 文件系统，当程序运行时，它的运行时挂载在‘/usr’上。 捆绑库(Bundled libraries)当一个程序需要的依赖不在运行时中，使用捆绑库来绑定这些依赖到程序上。 SDK(软件开发套件)SDK也是一个“运行时”，是用于构建应用程序的特殊类型的运行时，它包含了构建和打包工具（‘devel’ parts），如头文件，编译器和调试器。通常，SDK与“运行时”配对，由应用程序使用。 扩展(Extensions)一个扩展是对于运行时或程序的可选插件，一般用于把translations和debug信息从运行时分离出来，比如, org.freedesktop.Platform.Locale 可以追加到org.freedesktop.Platform运行时上用来添加翻译。 沙箱（Sandbox）使用Flatpak，每个应用程序都是在孤立的环境中构建和运行的。默认情况下，应用程序只能“查看”自身及其“运行时”,访问用户文件，网络，graphics sockets，总线和设备上的子系统必须明确授予权限，访问其他内容（如其他进程）是不允许的。（可以通过Portals机制在沙箱内访问外面系统，比如打印，截图等） Flatpak主要使用了如下技术： bubblewrap：依赖它作为沙箱的底层实现,限制了应用程序访问操作系统或用户数据的能力，并且提供了非特权用户使用容器的能力。 Systemd：将各个subsystem和cgroup树关联并挂载好，为沙箱创建 cgroups。 D-Bus, 为应用程序提供高层APIs。 使用Open Container Initiative的OCI格式作为单文件的传输格式，方便传输。 使用OSTree系统用于版本化和分发文件系统树。 使用Appstream元数据，使得Flatpak应用程序在软件中心可以完美呈现出来。 附：没想到你是这样的flatpak bubblewrap uses PR_SET_NO_NEW_PRIVS to turn off setuid binaries, which is the traditional way to get out of things like chroots. 12/* Never gain any more privs during exec */ if (prctl (PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) &lt; 0) bubblewrap works by creating a new, completely empty, mount namespace where the root is on a tmpfs that is invisible from the host, and will be automatically cleaned up when the last process exits.bubblewrap always creates a new mount namespace, and the user can specify exactly what parts of the filesystem should be visible in the sandbox.Any such directories you specify mounted nodev by default, and can be made readonly. namespaces目前，Linux内核里面实现了7种不同类型的namespace。 名称 宏定义 隔离内容 Cgroup CLONE_NEWCGROUP Cgroup root directory (since Linux 4.6) IPC CLONE_NEWIPC System V IPC, POSIX message queues (since Linux 2.6.19) Network CLONE_NEWNET Network devices, stacks, ports, etc. (since Linux 2.6.24) Mount CLONE_NEWNS Mount points (since Linux 2.4.19) PID CLONE_NEWPID Process IDs (since Linux 2.6.24) User CLONE_NEWUSER User and group IDs (started in Linux 2.6.23 and completed in Linux 3.8) UTS CLONE_NEWUTS Hostname and NIS domain name (since Linux 2.6.19) 查看当前bash进程所属的namespace: ls -l /proc/$$/nsnamespace相关的函数: clone: 创建一个新的进程并把他放到新的namespace中 12int clone(int (*child_func)(void *), void *child_statck, int flags, void *arg);flags: 指定一个或者多个上面的CLONE_NEW*(当然也可以包含跟namespace无关的flags),这样就会创建一个或多个新的不同类型的namespace,并新创建的子进程加入新创建的这些namespace中. setns: 将当前进程加入到已有的namespace中 12345int setns(int fd, int nstype);fd: 指向/proc/[pid]/ns/目录里相应namespace对应的文件,表示要加入哪个namespacenstype: 指定nsmespace的类型: 1. 如果当前进程不能根据fd得到它的类型,如fd由其他进程创建,并通过UNIX domain socket传给当前进程,那么就需要通过nstype来制定fd指向的namespace的类型. 2. 如果进程能根据fd得到namespace类型,比如这个fd是由当前进程打开的,那么nstype设置为0即可. unshare: 使当前进程退出指定类型的namespace,并加入到新创建的namespace(相当于创建并加入新的namespace) 12int unshare(int flags);flags: 指定一个或者多个namespace类型,这样当前进程就退出了当前指定类型的namespace并加入到新创建的namespace 当一个namespace中的所有进程都退出时，该namespace将会被销毁。当然还有其他方法让namespace一直存在，假设我们有一个进程号为1000的进程，以ipc namespace为例： 通过mount –bind命令。例如mount –bind /proc/1000/ns/ipc /other/file，就算属于这个ipc namespace的所有进程都退出了，只要/other/file还在，这个ipc namespace就一直存在，其他进程就可以利用/other/file，通过setns函数加入到这个namespace 在其他namespace的进程中打开/proc/1000/ns/ipc文件，并一直持有这个文件描述符不关闭，以后就可以用setns函数加入这个namespace。 unity7Compiz窗口管理器的一个插件，使用nux(opengl)图形库。部分采用cario直接绘制。添加动态调整整体布局以及kylin style的锁屏和dash，通过监控gsettings设置，条件判断+工厂模式。 unity8The Unity 8 Desktop Preview is the new Unity 8 desktop shell running on the Mir display technology.unity8(c++ + qml) + mirIf you want to run X11 applications that do not have native Mir support in the toolkit they use then the answer is an X11 server that runs on Mir. That could be either Xmir or Xwayland. ukui会话管理器, 按照X 会话管理协议 (XSMP)会话管理协议的主要部分是： 会话管理器为每个客户端选择一个唯一的标识符 会话管理器需要客户端保存他们的状态 客户端指定它该如何重启以便恢复状态（例如，使用命令行来启动程序） 窗口管理器使用窗口管理器时，Xserver 并不直接与其它 Xclient 通信，而是通过WM中转，当一些消息被定义为WM指令时，它们会被拦截。例如 Alt+F4 关闭窗口、拖动标题栏…… 系统启动过程：内核加载 –&gt; init程序运行 –&gt; systemd -&gt; 显示管理器运行(众多服务之一) –&gt; X Server 运行 –&gt; 显示管理器连接到 X Server，显示登录界面 –&gt; 用户登录后，登录界面关闭，加载桌面环境 从上面的流程可以看出，显示管理器是 X Server 的父进程，它负责启动 X Server，当 X Server 启动后，它又变成了 X Server 的一个 Client 程序，连接到 X Server 显示欢迎界面和登录界面，最后，显示管理器又是所有桌面环境的父进程，它负责启动桌面环境需要的其它 Client 程序。 lightdm 在启动 X Server 的时候，给 X Server 加上了 -nolisten tcp 参数，所以远程计算机就没有办法连接到 Ubuntu 的桌面了。","tags":[],"categories":[{"name":"others","slug":"others","permalink":"https://handsome-feng.github.io/1night-cs/categories/others/"}]},{"title":"","date":"2020-05-22T12:03:32.768Z","path":"wiki/others/计算机组成与设计/","text":"计算机组成与设计名词、术语机器零：机器数表示的零的形式，在数轴上表示为0点及其附近的一段区域 浮点数规格化： 串行进位： 并行进位： 微指令： 主存存取时间： 多重中断： 通道控制字： 总线目标设备： 指令系统： 定点数： 微操作： 外中断： 通道状态字： 相变型光盘： 总线宽度： 计算机的语言：MIPS 寄存器 寄存器号 用途 调用时是否保存 $zero 0 常数0 不适用 $v0 - $v1 2 ~ 3 返回值 否 $a0 - $a3 4 ~ 7 参数 否 $t0 - $t7 8 ~ 15 临时变量 否 $s0 - $s7 16 ~ 23 对应保存的变量 是 $t8 - $t9 24 ~ 25 更多临时变量 否 $gp 28 指向静态数据区的保留寄存器 是 $sp 29 栈指针 是 $fp 30 帧指针 是 $ra 31 返回地址 是 $at 1 汇编器保留 $k0 - $k1 26 ~ 27 操作系统保留 32个的理由： 越小越快 指令格式位数的限制 指令： add $s1, $s2, $s3 # $s1 = $s2 + $s3 sub $s1, $s2, $s3 # $s1 = $s2 - $s3 addi $s1, $s2, 20 # $s1 = $s2 + 20 补码取反加1原理：$$x + \\bar{x} = -1 \\x + \\bar{x} + 1 = 0 \\-x = \\bar{x} + 1$$ 将有符号数作为无符号数来处理，是一种检验 0 &lt;= x &lt; y 的低开销方法，常用于检查数组的下标是否越界 12345int fact (int n)&#123; if (n &lt; 1) return (1); else return (n * fact(n - 1));&#125; 12345678910111213141516fact: addi $sp, $sp, -8 sw $ra, 4($sp) sw $a0, 0($sp) slti $t0, $a0, 1 # test for n &lt; 1 beq $t0, $zero, L1 addi $v0, $zero, 1 # return 1 addi $sp, $sp, 8 # pop 2 items, 本应该加载$a0和$ra，但是n&lt;1时，没有变化 jr $raL1: addi $a0, $a0, -1 jal fact # call fact with (n - 1) lw $a0, 0($sp) # return from jal: restore argument n lw $ra, 4($sp) addi $sp, $sp, 8 mul $v0, $a0, $v0 # return n * fact (n - 1) jr $ra","tags":[],"categories":[{"name":"others","slug":"others","permalink":"https://handsome-feng.github.io/1night-cs/categories/others/"}]},{"title":"","date":"2020-05-22T12:03:32.740Z","path":"wiki/algorithm/动态规划/","text":"","tags":[],"categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://handsome-feng.github.io/1night-cs/categories/algorithm/"}]},{"title":"machine-learning","date":"2020-05-22T12:03:32.740Z","path":"wiki/AI/machine-learning/","text":"","tags":[],"categories":[{"name":"AI","slug":"AI","permalink":"https://handsome-feng.github.io/1night-cs/categories/AI/"}]},{"title":"","date":"2020-05-22T12:03:32.740Z","path":"wiki/algorithm/algorithm/","text":"数据结构概述数据是客观事物的符号表示，是对现实世界的事物采用计算机能够识别、存储和处理的形式进行描述的符号的集合。 数据元素是数据的基本单位 数据对象是性质相同的数据元素的集合，是数据集合的一个子集 数据结构的概念应包括三个方面： 数据元素及数据元素之间的逻辑关系，也称为数据的逻辑结构 数据元素及数据元素之间的关系在计算机中的存储表示，也称为数据的存储结构或物理结构 数据的运算，即对数据施加的操作 数据类型是一组性质相同的值的集合以及定义在这个集合上的一组操作的总称。 数据的逻辑结构分为： 线性结构中有且仅有一个开始结点和一个终端结点，并且所有的结点最多只有一个前驱和一个后继。 非线性结构中的一个结点可能有多个前驱和后继。 存储结构：顺序存储、链接存储、索引存储、散列存储 高级程序语言中，数据类型分为基本类型和组合类型 抽象：从特定的实例中抽取共同的性质形成一般化概念的过程 数据抽象 模块化 信息隐蔽 抽象数据类型：指抽象数据的组织和与之相关的操作 算法应当具有的特性： 输入 输出 确定性 有穷性 可行性 好的算法应满足： 正确性 可读性 健壮性 时间效率和存储占用量 树二叉树本质二叉树，本质上，是对链表和数组的一个折中在链表中，插入、删除速度很快，但查找速度较慢。在数组中，查找速度很快，但插入删除速度很慢。为了解决这个问题，找寻一种能够在插入、删除、查找、遍历等操作都相对快的容器，于是人们发明了二叉树。 二叉搜索树若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。 哈夫曼树（最优二叉树）通过某种规则（权值）来构造出一哈夫曼二叉树，在这个二叉树中，只有叶子节点才是有效的数据节点（很重要），其他的非叶子节点是为了构造出哈夫曼而引入的。 红黑树那么为了能够以较快的时间O(logN)来搜索一棵树，我们需要保证树总是平衡的（或者大部分是平衡的），也就是说每个节点的左子树节点个数和右子树节点个数尽量相等。红-黑树的就是这样的一棵平衡树，对一个要插入的数据项（删除也是），插入例程要检查会不会破坏树的特征，如果破坏了，程序就会进行纠正，根据需要改变树的结构，从而保持树的平衡。 1.每个节点不是红色就是黑色的； 2.根节点总是黑色的； 3.如果节点是红色的，则它的子节点必须是黑色的（反之不一定）,(也就是从每个叶子到根的所有路径上不能有两个连续的红色节点)； 4.从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。 注意：新插入的节点颜色总是红色的，这是因为插入一个红色节点比插入一个黑色节点违背红-黑规则的可能性更小，原因是插入黑色节点总会改变黑色高度（违背规则4），但是插入红色节点只有一半的机会会违背规则3（因为父节点是黑色的没事，父节点是红色的就违背规则3）。另外违背规则3比违背规则4要更容易修正。 应用： set/map底层都是用红黑树实现的 从上到下打印二叉树层序遍历直接想到的应该是基于队列实现。从上到下打印二叉树的规律：每一次打印一个结点的时候，如果该结点有子结点，则把该结点的子结点放到一个队列的末尾。接下来到队列头部取出最早进入队列的结点，重复前面的打印操作，直到队列中所有的结点都被打印出来为止。 哈希表与红黑树咋一看，hashtable的优势是很明显的： 查找、插入、删除速度都为O(1), 而红黑树的查找、插入、删除速度为O(logn). 但红黑树有很重要的特征是hashtable所不具备的： 有序的特征,红黑树遍历可以得出有序输出，但hashtable是无序输出。 如果需要求某一范围的输出，红黑树可以完美解决 hashtable的最恶劣的情况是效率很低的(比如需要resize时），而红黑树不存在这种情况。 堆完全二叉树，除了树的最后一层节点不需要是满的，其它的每一层从左到右都是满的。 2-3-4树2-3-4树每个节点最多有四个字节点和三个数据项，名字中 2,3,4 的数字含义是指一个节点可能含有的子节点的个数。对于非叶节点有三种可能的情况： 有一个数据项的节点总是有两个子节点； 有二个数据项的节点总是有三个子节点； 有三个数据项的节点总是有四个子节点； 简而言之，非叶节点的子节点数总是比它含有的数据项多1。如果子节点个数为L，数据项个数为D，那么：L = D + 1 根是child0的子树的所有子节点的关键字值小于key0； 根是child1的子树的所有子节点的关键字值大于key0并且小于key1； 根是child2的子树的所有子节点的关键字值大于key1并且小于key2； 根是child3的子树的所有子节点的关键字值大于key2。 B树应用场景：查找磁盘中的大量数据 满足： 若根结点不是终端结点，则至少有2棵子树 除根节点以外的所有非叶结点至少有 M/2 棵子树，至多有 M 个子树（关键字数为子树减一） 所有的叶子结点都位于同一层 B+树满足： 节点的子树数和关键字数相同（B 树是关键字数比子树数少一） 节点的关键字表示的是子树中的最大数，在子树中同样含有这个数据 叶子节点包含了全部数据，同时符合左小右大的顺序 图图的存储表示 邻接矩阵 邻接矩阵是一个二维数组，数据项表示两点间是否存在边，如果图中有 N 个顶点，邻接矩阵就是 N*N 的数组。 邻接表 邻接表是一个链表数组（或者是链表的链表），每个单独的链表表示了有哪些顶点与当前顶点邻接。 邻接多重表 图的遍历 深度优先遍历 广度优先遍历 最小代价生成树算法如何判断一个点在多边形内多个字符串中如何找到前缀相同最长的两个字符串棋子走日字，从左下角到右上角，有多少走法一分钟公交通过概率为p，3min呢mysql数据存储过程，B数，哈析表如何查看单链表倒数第K个数据设链表的长度为 N。设两个指针 P1 和 P2指向单链表头部，先让 P1 移动 K 个节点，则还有 N - K 个节点可以移动。此时让 P1 和 P2 同时移动，可以知道当 P1 移动到链表结尾时，P2 移动到 N - K 个节点处，该位置就是倒数第 K 个节点。 找到链表中环的入口节点 找环中相汇点。分别用p1，p2指向链表头部，p1每次走一步，p2每次走二步，直到p1==p2找到在环中的相汇点。 找环的长度。从环中的相汇点开始, p2不动, p1前移，当再次相遇时，p1刚好绕环一周,其移动即为环的长度K 求换的起点, 转换为求环的倒数第N-K个节点，则两指针left和right均指向起始,right先走K步,然后两个指针开始同步移动,当两个指针再次相遇时,right刚好绕环一周回到起点,left则刚好走到了起点位置 二维数组中的查找在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。思路:从右上角开始查找。因为矩阵中的一个数，它左边的数都比它小，下边的数都比它大。因此，从右上角开始查找，就可以根据 target 和当前元素的大小关系来缩小查找区间。 复杂度：O(M+N) + O(1) 从尾到头打印链表 使用栈 使用递归(本质也是栈) 使用头插法 斐波那契数列动态规划 在O(1)时间内删除链表节点 如果该节点不是尾节点，那么可以直接将下一个节点的值赋给该节点，令该节点指向下下个节点，然后删除下一个节点，时间复杂度为 O(1)。 否则，就需要先遍历链表，找到节点的前一个节点，然后让前一个节点指向 null，时间复杂度为 O(N)。 设计包含min函数的栈除了题目要求的栈之外新开一个栈,用来记录最小值,每当在原栈中push数据后,与最小值栈中的栈顶元素比较,如果新值较小,则在最小值栈中push新值;否则再次push栈顶元素.pop的时候,只要将最小值栈也pop一下就行了.这样,min函数只需要返回最小值栈的栈顶元素即可. 12345public void push(int node) &#123; stack.push(node); if (min &gt; node) min = node; minStack.push(min);&#125; 一个优化:一般说来,最小值不会每次都需要更新,因此最小值栈里面会有很多重复元素.因此一个简单的优化就是只在新值&lt;=原最小值时才pushIntoMin,注意这个==的条件是不可少的,这是为了防止在pop的时候错误的pop最小值.pop的时候,只有pop值==最小值时才popMinStack, 其他时候不对最小值栈进行pop 排序算法选择排序1234567891011template&lt;typename T&gt;void selectionSort (T arr[], int n) &#123; for (int i = 0; i &lt; n; i++) &#123; int minIndex = i; for (int j = i + 1; j &lt; n; j++) if (arr[j] &lt; arr[minIndex]) minIndex = j; swap (arr[i], arr[minIndex]); &#125;&#125; 插入排序123456789template&lt;typename T&gt;void insertionSort (T arr[], int n) &#123; for (int i = 1; i &lt; n; i++) &#123; // 寻找arr[i]合适的插入位置 for (int j = i; j &gt; 0 &amp;&amp; arr[j] &lt; arr[j-1]; j--) &#123; swap (arr[j], arr[j-1]); //一次交换=三次赋值 &#125; &#125;&#125; 1234567891011template&lt;typename T&gt;void insertionSort2 (T arr[], int n) &#123; for (int i = 1; i &lt; n; i++) &#123; T e = arr[i]; int j; //保存元素e应该插入的位置 for (j = i; j &gt; 0 &amp;&amp; arr[j-1] &gt; e; j--) &#123; arr[j] = arr[j-1]; //向后移动 &#125; arr[j] = e; &#125;&#125; 对于近乎有序的数组，效率极高，近似于O(n)。 冒泡排序合并排序快速排序","tags":[],"categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://handsome-feng.github.io/1night-cs/categories/algorithm/"}]},{"title":"","date":"2020-05-22T12:03:32.740Z","path":"wiki/algorithm/链表/单链表逆置/","text":"头插法(有头指针，迭代)1234567891011121314void list_revert(Node *head) &#123; if (!head) return -1; Node *p, *q; p = head-&gt;next; head-&gt;next = NULL; while (p) &#123; q = p; p = p-&gt;next; q-&gt;next = head-&gt;next; head-&gt;next = q; &#125;&#125; 就地逆置法12345678910Node *list_revert(Node *head) &#123; if (head == NULL || head-&gt;next == NULL) return head; Node *pRev = NULL; Node *pCur = head; whiel (pCur != NULL) &#123; Node *tmp = pCur; p &#125;&#125;","tags":[],"categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://handsome-feng.github.io/1night-cs/categories/algorithm/"},{"name":"链表","slug":"algorithm/链表","permalink":"https://handsome-feng.github.io/1night-cs/categories/algorithm/链表/"}]}]}